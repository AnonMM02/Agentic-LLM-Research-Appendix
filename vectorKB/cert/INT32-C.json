[
  {
    "id": "INT32-C_pdf_0",
    "source": "CERT_PDF",
    "cert_rule": "INT32-C",
    "title": "Ensure that operations on signed integers do not result in",
    "kind": "description",
    "text": "overflow Signed integer overflow is undefined behavior 36. Consequently, implementations have consider- able latitude in how they deal with signed integer overflow. (See MSC15-C. Do not depend on undefined behavior.) An implementation that defines signed integer types as being modulo, for example, need not detect integer overflow. Implementations may also trap on signed arithmetic overflows, or simply assume that overflows will never happen and generate object code accord- ingly. It is also possible for the same conforming implementation to emit code that exhibits dif- ferent behavior in different contexts. For example, an implementation may determine that a signed integer loop control variable declared in a local scope cannot overflow and may emit efficient code on the basis of that determination, while the same implementation may determine that a global variable used in a similar context will wrap. For these reasons, it is important to ensure that operations on signed integers do not result in over- flow."
  },
  {
    "id": "INT32-C_pdf_1",
    "source": "CERT_PDF",
    "cert_rule": "INT32-C",
    "title": "Ensure that operations on signed integers do not result in",
    "kind": "description",
    "text": "Of particular importance are operations on signed integer values that originate from a tainted source and are used as • Integer operands of any pointer arithmetic, including array indexing • The assignment expression for the declaration of a variable length array • The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object • Function arguments of type size_t or rsize_t (for example, an argument to a memory al- location function) Integer operations will overflow if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operations can result in over- flow. Operator Overflow Operator Overflow Operator Overflow Operator Overflow + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= Yes & No >= No / Yes %= Yes | No <= No % Yes <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No unary + No || No += Yes ^= No unary - Yes ?: No The following sections examine specific operations that are susceptible to integer overflow. When operating on integer types with less precision than , integer promotions are applied. The usual int arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed."
  },
  {
    "id": "INT32-C_pdf_2",
    "source": "CERT_PDF",
    "cert_rule": "INT32-C",
    "title": "Ensure that operations on signed integers do not result in",
    "kind": "description",
    "text": "Programmers should understand integer conversion SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 147 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Integers (INT) - INT32-C. Ensure that operations on signed integers do not result in overflow rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules.) 5.3.1 Implementation Details GNU GCC invoked with the command-line option defines the same modulo arithmetic -fwrapv for both unsigned and signed integers. GNU GCC invoked with the command-line option causes a trap to be generated when a -ftrapv signed integer overflows, which will most likely abnormally exit. On a UNIX system, the result of such an event may be a signal sent to the process. GNU GCC invoked without either the or the option may simply assume that -fwrapv -ftrapv signed integers never overflow and may generate object code accordingly. 5.3.2 Atomic Integers The C Standard defines the behavior of arithmetic on atomic signed integer types to use two’s complement representation with silent wraparound on overflow; there are no undefined results. Although defined, these results may be unexpected and therefore carry similar risks to unsigned integer wrapping. (See INT30-C."
  },
  {
    "id": "INT32-C_pdf_3",
    "source": "CERT_PDF",
    "cert_rule": "INT32-C",
    "title": "Ensure that operations on signed integers do not result in",
    "kind": "description",
    "text": "Ensure that unsigned integer operations do not wrap.) Conse- quently, signed integer overflow of atomic integer types should also be prevented or detected. 5.3.3 Addition Addition is between two operands of arithmetic type or between a pointer to an object type and an integer type. This rule applies only to addition between two operands of arithmetic type. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts.) Incrementing is equivalent to adding 1. 5.3.3.1"
  },
  {
    "id": "INT32-C_samples_c0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c0.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid f(signed int si_a, signed int si_b) {\n  signed int sum;\n  if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||\n      ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {\n    /* Handle error */\n  } else {\n    sum = si_a + si_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c1.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c1.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed int si_a, signed int si_b) {\n  signed int diff;\n  if ((si_b > 0 && si_a < INT_MIN + si_b) ||\n      (si_b < 0 && si_a > INT_MAX + si_b)) {\n    /* Handle error */\n  } else {\n    diff = si_a - si_b;\n  }\n \n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c2.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c2.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <stddef.h>\n#include <assert.h>\n#include <limits.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n   \nvoid func(signed int si_a, signed int si_b) {\n  signed int result;\n  signed long long tmp;\n  assert(PRECISION(ULLONG_MAX) >= 2 * PRECISION(UINT_MAX));\n  tmp = (signed long long)si_a * (signed long long)si_b;\n  \n  /*\n   * If the product cannot be represented as a 32-bit integer,\n   * handle as an error condition.\n   */\n  if ((tmp > INT_MAX) || (tmp < INT_MIN)) {\n    /* Handle error */\n  } else {\n    result = (int)tmp;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c3.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c3.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed int si_a, signed int si_b) {\n  signed int result; \n  if (si_a > 0) {  /* si_a is positive */\n    if (si_b > 0) {  /* si_a and si_b are positive */\n      if (si_a > (INT_MAX / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a positive, si_b nonpositive */\n      if (si_b < (INT_MIN / si_a)) {\n        /* Handle error */\n      }\n    } /* si_a positive, si_b nonpositive */\n  } else { /* si_a is nonpositive */\n    if (si_b > 0) { /* si_a is nonpositive, si_b is positive */\n      if (si_a < (INT_MIN / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a and si_b are nonpositive */\n      if ( (si_a != 0) && (si_b < (INT_MAX / si_a))) {\n        /* Handle error */\n      }\n    } /* End if si_a and si_b are nonpositive */\n  } /* End if si_a is nonpositive */\n \n  result = si_a * si_b;\n}\n"
  },
  {
    "id": "INT32-C_samples_c4.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c4.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c5.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c5.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  } \n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c6.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c6.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_c7.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/c7.c",
    "kind": "compliant",
    "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a) {\n  signed long result;\n  if (s_a == LONG_MIN) {\n    /* Handle error */\n  } else {\n    result = -s_a;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc0.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int sum = si_a + si_b;\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc1.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc1.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int diff = si_a - si_b;\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc2.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc2.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int result = si_a * si_b;\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc3.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc3.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc4.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc4.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc5.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc5.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT32-C_samples_nc6.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT32-C",
    "file_path": "rules/int/32/nc6.c",
    "kind": "noncompliant",
    "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a) {\n  signed long result = -s_a;\n  /* ... */\n}\n"
  }
]