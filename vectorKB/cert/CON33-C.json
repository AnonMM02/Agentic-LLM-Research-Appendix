[
  {
    "id": "CON33-C_pdf_0",
    "source": "CERT_PDF",
    "cert_rule": "CON33-C",
    "title": "Avoid race conditions when using library functions",
    "kind": "description",
    "text": "Some C standard library functions are not guaranteed to be reentrant with respect to threads. Functions such as and return a pointer to the result stored in function-allo- strtok() asctime() cated memory on a per-process basis. Other functions such as store state information in rand() function-allocated memory on a per-process basis. Multiple threads invoking the same function can cause concurrency problems, which often result in abnormal behavior and can cause more se- rious vulnerabilities, such as abnormal termination, denial-of-service attack, and data integrity vi- olations. According to the C Standard, the library functions listed in the following table may contain data races when invoked by multiple threads. Functions Remediation , MSC30-C. Do not use the rand() function for rand() srand() generating pseudorandom numbers , ENV34-C."
  },
  {
    "id": "CON33-C_pdf_1",
    "source": "CERT_PDF",
    "cert_rule": "CON33-C",
    "title": "Avoid race conditions when using library functions",
    "kind": "description",
    "text": "Do not store pointers returned by getenv() getenv_s() certain functions in C11 Annex K strtok() strtok_s() in POSIX strtok_r() in C11 Annex K strerror() strerror_s() in POSIX strerror_r() , , , , asctime() ctime() asctime_s() ctime_s() local- , , in C11 Annex K localtime() gmtime() time_s() gmtime_s() Protect multithreaded access to locale-specific setlocale() functions with a mutex , Do not attempt to initialize an atomic variable ATOMIC_VAR_INIT atomic_init() from multiple threads in C11 Annex K tmpnam() tmpnam_s() in POSIX tmpnam_r() , , Do not call with a null argu- mbrtoc16() c16rtomb() mbstate_t * , ment mbrtoc32() c32rtomb() Section 2.9.1 of the Portable Operating System Interface (POSIXÂ®), Base Specifications, Issue 7 [IEEE Std 1003.1:2013] extends the list of functions that are not required to be thread-safe. 14.4.1"
  },
  {
    "id": "CON33-C_samples_c0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "CON33-C",
    "file_path": "rules/con/33/c0.c",
    "kind": "compliant",
    "text": "// CON33-C: Compliant Solution (Annex K, strerror_s()) \n#define __STDC_WANT_LIB_EXT1__ 1\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n  \nenum { BUFFERSIZE = 64 };\nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_s(errmsg, BUFFERSIZE, errno) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"
  },
  {
    "id": "CON33-C_samples_c1.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "CON33-C",
    "file_path": "rules/con/33/c1.c",
    "kind": "compliant",
    "text": "// CON33-C: Compliant Solution (POSIX, strerror_r())\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n \nenum { BUFFERSIZE = 64 };\n  \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_r(errno, errmsg, BUFFERSIZE) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"
  },
  {
    "id": "CON33-C_samples_nc0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "CON33-C",
    "file_path": "rules/con/33/nc0.c",
    "kind": "noncompliant",
    "text": "// CON33-C: Noncompliant Code Example\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n  \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char *errmsg = strerror(errno);\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"
  }
]