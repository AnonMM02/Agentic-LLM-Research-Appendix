[
  {
    "id": "INT34-C_pdf_0",
    "source": "CERT_PDF",
    "cert_rule": "INT34-C",
    "title": "Do not shift an expression by a negative number of bits or",
    "kind": "description",
    "text": "by greater than or equal to the number of bits that exist in the operand Bitwise shifts include left-shift operations of the form shift-expression additive-expression and << right-shift operations of the form shift-expression additive-expression. The standard integer pro- >> motions are first performed on the operands, each of which has an integer type. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. (See undefined behavior 51.) Do not shift an expression by a negative number of bits or by a number greater than or equal to the precision of the promoted left operand. The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. For unsigned integer types, the width and the precision are the same; whereas for signed integer types, the width is one greater than the precision. This rule uses precision instead of width because, in almost every case, an at- tempt to shift by a number of bits greater than or equal to the precision of the operand indicates a bug (logic error). A logic error is different from overflow, in which there is simply a representa- tional deficiency. In general, shifts should be performed only on unsigned operands. (See INT13- C. Use bitwise operators only on unsigned operands.) 5.5.1"
  },
  {
    "id": "INT34-C_samples_c0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/c0.c",
    "kind": "compliant",
    "text": "// INT34-C: Compliant Solution (Left Shift, Unsigned Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a << ui_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT34-C_samples_c1.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/c1.c",
    "kind": "compliant",
    "text": "// INT34-C: Compliant Solution (Left Shift, Signed Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT34-C_samples_c2.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/c2.c",
    "kind": "compliant",
    "text": "// INT34-C: Compliant Solution (Right Shift)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a >> ui_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT34-C_samples_nc0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/nc0.c",
    "kind": "noncompliant",
    "text": "// INT34-C: Noncompliant Code Example (Left Shift, Unsigned Type)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a << ui_b;\n  /* ... */\n}\n"
  },
  {
    "id": "INT34-C_samples_nc1.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/nc1.c",
    "kind": "noncompliant",
    "text": "// INT34-C: Noncompliant Code Example (Left Shift, Signed Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if (si_a > (LONG_MAX >> si_b)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"
  },
  {
    "id": "INT34-C_samples_nc2.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "INT34-C",
    "file_path": "rules/int/34/nc2.c",
    "kind": "noncompliant",
    "text": "// INT34-C: Noncompliant Code Example (Right Shift)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a >> ui_b;\n  /* ... */\n}\n"
  }
]