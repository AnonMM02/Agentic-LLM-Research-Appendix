[
  {
    "id": "ARR36-C_pdf_0",
    "source": "CERT_PDF",
    "cert_rule": "ARR36-C",
    "title": "Do not subtract or compare two pointers that do not",
    "kind": "description",
    "text": "refer to the same array When two pointers are subtracted, both must point to elements of the same array object or just one past the last element of the array object (C Standard, 6.5.6 [ISO/IEC 9899:2011]); the result is the difference of the subscripts of the two array elements. Otherwise, the operation is undefined be- havior. (See undefined behavior 48.) Similarly, comparing pointers using the relational operators , , , and gives the positions of < <= >= > the pointers relative to each other. Subtracting or comparing pointers that do not refer to the same array is undefined behavior. (See undefined behavior 48 and undefined behavior 53.) Comparing pointers using the equality operators and has well-defined semantics regardless == != of whether or not either of the pointers is null, points into the same object, or points one past the last element of an array object or function. 7.3.1"
  },
  {
    "id": "ARR36-C_samples_c0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "ARR36-C",
    "file_path": "rules/arr/36/c0.c",
    "kind": "compliant",
    "text": "// ARR36-C: Compliant Solution\n#include <stddef.h>\nenum { SIZE = 32 };\n  \nvoid func(void) {\n  int nums[SIZE];\n  int *next_num_ptr = nums;\n  size_t free_elements;\n \n  /* Increment next_num_ptr as array fills */\n \n  free_elements = &(nums[SIZE]) - next_num_ptr;\n}\n"
  },
  {
    "id": "ARR36-C_samples_nc0.c",
    "source": "CERT_SAMPLES",
    "cert_rule": "ARR36-C",
    "file_path": "rules/arr/36/nc0.c",
    "kind": "noncompliant",
    "text": "// ARR36-C: Noncompliant Code Example\n#include <stddef.h>\n  \nenum { SIZE = 32 };\n  \nvoid func(void) {\n  int nums[SIZE];\n  int end;\n  int *next_num_ptr = nums;\n  size_t free_elements;\n \n  /* Increment next_num_ptr as array fills */\n \n  free_elements = &end - next_num_ptr;\n}\n"
  }
]