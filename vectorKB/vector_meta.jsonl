{"id": "CWE-121_0", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "Description: A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function). Consequences: Availability Modify Memory DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop. Integrity Confidentiality Availability Access Control Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Integrity Confidentiality Availability Access Control Other Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service. Mitigations: Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-121_1", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Implementation Implement and perform bounds checking on input. Implementation Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-121_2", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-122_0", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Description: A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc(). Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop. Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Modify Memory Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime. Integrity Confidentiality Availability Access Control Other Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service.", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_1", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Mitigations: Pre-design: Use a language or compiler that performs automatic bounds checking. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_2", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Implementation Implement and perform bounds checking on input. Implementation Libraries or Frameworks Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary. Operation Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption.", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_3", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-1260_0", "source": "CWE", "cwe_id": "CWE-1260", "title": "Improper Handling of Overlap Between Protected Memory Ranges", "text": "Description: The product allows address regions to overlap, which can result in the bypassing of intended memory protection. Extended Description: Isolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software. If a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions. Consequences: Confidentiality Integrity Availability Modify Memory Read Memory DoS: Instability High Mitigations: Architecture and Design Ensure that memory regions are isolated as intended and that access control (read/write) policies are used by hardware to protect privileged software. Implementation For all of the programmable memory protection regions, the memory protection unit (MPU) design can define a priority scheme.", "url": "https://cwe.mitre.org/data/definitions/1260.html"}
{"id": "CWE-1260_1", "source": "CWE", "cwe_id": "CWE-1260", "title": "Improper Handling of Overlap Between Protected Memory Ranges", "text": "For example: if three memory regions can be programmed (Region_0, Region_1, and Region_2), the design can enforce a priority scheme, such that, if a system address is within multiple regions, then the region with the lowest ID takes priority and the access-control policy of that region will be applied. In some MPU designs, the priority scheme can also be programmed by trusted software. Hardware logic or trusted firmware can also check for region definitions and block programming of memory regions with overlapping addresses. The memory-access-control-check filter can also be designed to apply a policy filter to all of the overlapping ranges, i.e., if an address is within Region_0 and Region_1, then access to this address is only granted if both Region_0 and Region_1 policies allow the access. High Detection Methods: Manual Analysis Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test. High", "url": "https://cwe.mitre.org/data/definitions/1260.html"}
{"id": "CWE-131_0", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Description: The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow. Consequences: Integrity Availability Confidentiality DoS: Crash, Exit, or Restart Execute Unauthorized Code or Commands Read Memory Modify Memory If the incorrect calculation is used in the context of memory allocation, then the software may create a buffer that is smaller or larger than expected. If the allocated buffer is smaller than expected, this could lead to an out-of-bounds read or write (CWE-119), possibly causing a crash, allowing arbitrary code execution, or exposing sensitive data. Mitigations: Implementation When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts \"&\" characters to \"&amp;\" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer. Implementation Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_1", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "[REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation. Implementation Input Validation Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Implementation When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130). Implementation When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated. Implementation Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_2", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Moderate This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131). Additionally, this only addresses potential overflow issues. Resource consumption / exhaustion issues are still possible. Implementation Use sizeof() on the appropriate data type to avoid CWE-467. Implementation Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify validation and will reduce surprises related to unexpected casting. Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106] Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_3", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_4", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Operation Environment Hardening Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. Defense in Depth This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application. Implementation Compilation or Build Hardening Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_5", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system. Architecture and Design Operation Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Architecture and Design Operation Sandbox or Jail Run the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_6", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Limited The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed. Detection Methods: Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges. High Detection techniques for buffer-related errors are more mature than for most other weakness types. Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_7", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Moderate Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem. Manual Analysis Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large. Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program. High These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_8", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis High Manual Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections) SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-1335_0", "source": "CWE", "cwe_id": "CWE-1335", "title": "Incorrect Bitwise Shift of Integer", "text": "Description: An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result. Extended Description: Specifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue. Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result. Consequences: Integrity DoS: Crash, Exit, or Restart Mitigations: Implementation Implicitly or explicitly add checks and mitigation for negative or over-shift values.", "url": "https://cwe.mitre.org/data/definitions/1335.html"}
{"id": "CWE-190_0", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Description: The product performs a calculation that can produce an integer overflow or wraparound when the logic assumes that the resulting value will always be larger than the original value. This occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may become a very small or negative number. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (Memory) DoS: Instability This weakness can generally lead to undefined behavior and therefore crashes. When the calculated result is used for resource allocation, this weakness can cause too many (or too few) resources to be allocated, possibly enabling crashes if the product requests more resources than can be provided. Integrity Modify Memory If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the overflow/wraparound results in other conditions such as buffer overflows, further memory corruption may occur. Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism This weakness can sometimes trigger buffer overflows, which can be used to execute arbitrary code. This is usually outside the scope of the product's implicit security policy.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_1", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Availability Other Alter Execution Logic DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) If the overflow/wraparound occurs in a loop index variable, this could cause the loop to terminate at the wrong time - too early, too late, or not at all (i.e., infinite loops). With too many iterations, some loops could consume too many resources such as memory, file handles, etc., possibly leading to a crash or other DoS. Access Control Bypass Protection Mechanism If integer values are used in security-critical decisions, such as calculating quotas or allocation limits, integer overflows can be used to cause an incorrect security decision. Mitigations: Requirements Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol. Requirements Language Selection Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. If possible, choose a language or compiler that performs automatic bounds checking. Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_2", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "[REF-106] Implementation Input Validation Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values. Implementation Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation. Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_3", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Implementation Compilation or Build Hardening Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system. Detection Methods: Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. High Black Box Sometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Moderate Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem. Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_4", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program. High These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_5", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis High Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections) SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-191_0", "source": "CWE", "cwe_id": "CWE-191", "title": "Integer Underflow (Wrap or Wraparound)", "text": "Description: The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result. Extended Description: This can happen in signed and unsigned cases. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Instability This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high. Integrity Modify Memory If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur. Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/191.html"}
{"id": "CWE-191_1", "source": "CWE", "cwe_id": "CWE-191", "title": "Integer Underflow (Wrap or Wraparound)", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/191.html"}
{"id": "CWE-196_0", "source": "CWE", "cwe_id": "CWE-196", "title": "Unsigned to Signed Conversion Error", "text": "Description: The product uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value if the value of the unsigned primitive can not be represented using a signed primitive. Extended Description: Although less frequent an issue than signed-to-unsigned conversion, unsigned-to-signed conversion can be the perfect precursor to dangerous buffer underwrite conditions that allow attackers to move down the stack where they otherwise might not have access in a normal buffer overflow condition. Buffer underwrites occur frequently when large unsigned values are cast to signed values, and then used as indexes into a buffer or for pointer arithmetic. Consequences: Availability DoS: Crash, Exit, or Restart Incorrect sign conversions generally lead to undefined behavior, and therefore crashes. Integrity Modify Memory If a poor cast lead to a buffer overflow or similar condition, data integrity may be affected. Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Improper signed-to-unsigned conversions without proper checking can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy. Mitigations: Requirements Choose a language which is not subject to these casting flaws. Architecture and Design Design object accessor functions to implicitly check values for valid sizes.", "url": "https://cwe.mitre.org/data/definitions/196.html"}
{"id": "CWE-196_1", "source": "CWE", "cwe_id": "CWE-196", "title": "Unsigned to Signed Conversion Error", "text": "Ensure that all functions which will be used as a size are checked previous to use as a size. If the language permits, throw exceptions rather than using in-band errors. Implementation Error check the return values of all functions. Be aware of implicit casts made, and use unsigned variables for sizes if at all possible.", "url": "https://cwe.mitre.org/data/definitions/196.html"}
{"id": "CWE-252_0", "source": "CWE", "cwe_id": "CWE-252", "title": "Unchecked Return Value", "text": "Description: The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions. Extended Description: Two common programmer assumptions are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges. Consequences: Availability Integrity Unexpected State DoS: Crash, Exit, or Restart An unexpected return value could place the system in a state that could lead to a crash or other unintended behaviors. Mitigations: Implementation Check the results of all functions that return a value and verify that the value is expected. High Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. Implementation For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use.", "url": "https://cwe.mitre.org/data/definitions/252.html"}
{"id": "CWE-252_1", "source": "CWE", "cwe_id": "CWE-252", "title": "Unchecked Return Value", "text": "When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished [REF-1484]. Implementation Ensure that you account for all possible return values from the function. Implementation When designing a function, make sure you return a value or throw an exception in case of an error. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/252.html"}
{"id": "CWE-362_0", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Description: The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently. Extended Description: A race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_1", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Resource Consumption (Other) When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion. Availability DoS: Crash, Exit, or Restart DoS: Instability When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash. Confidentiality Integrity Read Files or Directories Read Application Data When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59). Access Control Execute Unauthorized Code or Commands Gain Privileges or Assume Identity Bypass Protection Mechanism This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. Mitigations: Architecture and Design In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance. Architecture and Design Use thread-safe capabilities such as the data access abstraction in Spring.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_2", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Architecture and Design Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400). Implementation When using multithreading and operating on shared variables, only use thread-safe functions. Implementation Use atomic operations on shared variables. Be wary of innocent-looking constructs such as \"x++\". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write. Implementation Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412. Implementation Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization. Implementation Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop. Implementation Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_3", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Architecture and Design Operation Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Detection Methods: Black Box Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable. White Box Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609). Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_4", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_5", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Moderate Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis High Dynamic Analysis with Automated Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners SOAR Partial Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Framework-based Fuzzer Cost effective for partial coverage: Fuzz Tester Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious High Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-369_0", "source": "CWE", "cwe_id": "CWE-369", "title": "Divide By Zero", "text": "Description: The product divides a value by zero. Extended Description: This weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height. Consequences: Availability DoS: Crash, Exit, or Restart A Divide by Zero results in a crash. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/369.html"}
{"id": "CWE-393_0", "source": "CWE", "cwe_id": "CWE-393", "title": "Return of Wrong Status Code", "text": "Description: A function or operation returns an incorrect return value or status code that does not indicate the true result of execution, causing the product to modify its behavior based on the incorrect result. Extended Description: This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe or correct, even when it is not. Consequences: Integrity Other Unexpected State Alter Execution Logic This weakness could place the system in a state that could lead unexpected logic to be executed or other unintended behaviors. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/393.html"}
{"id": "CWE-401_0", "source": "CWE", "cwe_id": "CWE-401", "title": "Missing Release of Memory after Effective Lifetime", "text": "Description: The product does not sufficiently track and release allocated memory after it has been used, making the memory unavailable for reallocation and reuse. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Instability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Most memory leaks result in general product reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker might be able to launch a denial of service attack (by crashing or hanging the program) or take advantage of other unexpected program behavior resulting from a low memory condition. Other Reduce Performance Mitigations: Implementation Libraries or Frameworks Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone. For example, glibc in Linux provides protection against free of invalid pointers. When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391]. To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution.", "url": "https://cwe.mitre.org/data/definitions/401.html"}
{"id": "CWE-401_1", "source": "CWE", "cwe_id": "CWE-401", "title": "Missing Release of Memory after Effective Lifetime", "text": "Architecture and Design Build and Compilation The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code. This is not a complete solution as it is not 100% effective. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/401.html"}
{"id": "CWE-415_0", "source": "CWE", "cwe_id": "CWE-415", "title": "Double Free", "text": "Description: The product calls free() twice on the same memory address. Consequences: Integrity Confidentiality Availability Modify Memory Execute Unauthorized Code or Commands When a program calls free() twice with the same argument, the program's memory management data structures may become corrupted, potentially leading to the reading or modification of unexpected memory addresses. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack. Doubly freeing memory may result in a write-what-where condition, allowing an attacker to execute arbitrary code. Mitigations: Architecture and Design Choose a language that provides automatic memory management. Implementation Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once. Implementation Use a static analysis tool to find double free instances.", "url": "https://cwe.mitre.org/data/definitions/415.html"}
{"id": "CWE-415_1", "source": "CWE", "cwe_id": "CWE-415", "title": "Double Free", "text": "Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/415.html"}
{"id": "CWE-416_0", "source": "CWE", "cwe_id": "CWE-416", "title": "Use After Free", "text": "Description: The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer. Consequences: Integrity Modify Memory The use of previously freed memory may corrupt valid data, if the memory area in question has been allocated and used properly elsewhere. Availability DoS: Crash, Exit, or Restart If chunk consolidation occurs after the use of previously freed data, the process may crash when invalid data is used as chunk information. Integrity Confidentiality Availability Execute Unauthorized Code or Commands If malicious data is entered before chunk consolidation can take place, it may be possible to take advantage of a write-what-where primitive to execute arbitrary code. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved. Mitigations: Architecture and Design Language Selection Choose a language that provides automatic memory management. Implementation Attack Surface Reduction When freeing pointers, be sure to set them to NULL once they are freed.", "url": "https://cwe.mitre.org/data/definitions/416.html"}
{"id": "CWE-416_1", "source": "CWE", "cwe_id": "CWE-416", "title": "Use After Free", "text": "However, the utilization of multiple or complex data structures may lower the usefulness of this strategy. Defense in Depth If a bug causes an attempted access of this pointer, then a NULL dereference could still lead to a crash or other unexpected behavior, but it will reduce or eliminate the risk of code execution. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/416.html"}
{"id": "CWE-457_0", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Description: The code uses a variable that has not been initialized, leading to unpredictable or unintended results. Extended Description: In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code. Consequences: Availability Integrity Other Other Initial variables usually contain junk, which can not be trusted for consistency. This can lead to denial of service conditions, or modify control flow in unexpected ways. In some cases, an attacker can \"pre-initialize\" the variable using previous actions, which might enable code execution. This can cause a race condition if a lock variable check passes when it should not. Authorization Other Other Strings that are not initialized are especially dangerous, since many functions expect a null at the end -- and only at the end -- of a string. Mitigations: Implementation Attack Surface Reduction Ensure that critical variables are initialized before first use [REF-1485].", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-457_1", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Build and Compilation Compilation or Build Hardening Most compilers will complain about the use of uninitialized variables if warnings are turned on. Implementation Operation When using a language that does not require explicit declaration of variables, run or compile the software in a mode that reports undeclared or unknown variables. This may indicate the presence of a typographic error in the variable's name. Requirements Language Selection Choose a language that is not susceptible to these issues. Architecture and Design Mitigating technologies such as safe string libraries and container abstractions could be introduced. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-457_2", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-463_0", "source": "CWE", "cwe_id": "CWE-463", "title": "Deletion of Data Structure Sentinel", "text": "Description: The accidental deletion of a data-structure sentinel can cause serious programming logic problems. Extended Description: Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety. Consequences: Availability Other Other Generally this error will cause the data structure to not work properly. Authorization Other Other If a control character, such as NULL is removed, one may cause resource access control problems. Mitigations: Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Build and Compilation Compilation or Build Hardening Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.", "url": "https://cwe.mitre.org/data/definitions/463.html"}
{"id": "CWE-463_1", "source": "CWE", "cwe_id": "CWE-463", "title": "Deletion of Data Structure Sentinel", "text": "Defense in Depth This is not necessarily a complete solution, since these mechanisms can only detect certain types of overflows. In addition, an attack could still cause a denial of service, since the typical response is to exit the application. Operation Use OS-level preventative functionality. Not a complete solution.", "url": "https://cwe.mitre.org/data/definitions/463.html"}
{"id": "CWE-469_0", "source": "CWE", "cwe_id": "CWE-469", "title": "Use of Pointer Subtraction to Determine Size", "text": "Description: The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk. Consequences: Access Control Integrity Confidentiality Availability Modify Memory Read Memory Execute Unauthorized Code or Commands Gain Privileges or Assume Identity There is the potential for arbitrary code execution with privileges of the vulnerable program. Mitigations: Implementation Save an index variable. This is the recommended solution. Rather than subtract pointers from one another, use an index variable of the same size as the pointers in question. Use this variable to \"walk\" from one pointer to the other and calculate the difference. Always validate this number. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/469.html"}
{"id": "CWE-469_1", "source": "CWE", "cwe_id": "CWE-469", "title": "Use of Pointer Subtraction to Determine Size", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/469.html"}
{"id": "CWE-476_0", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Description: The product dereferences a pointer that it expects to be valid but is NULL. Consequences: Availability DoS: Crash, Exit, or Restart NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation. Integrity Confidentiality Execute Unauthorized Code or Commands Read Memory Modify Memory In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution. Mitigations: Implementation For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished [REF-1484]. Requirements Select a programming language that is not susceptible to these issues. Implementation Check the results of all functions that return a value and verify that the value is non-null before acting upon it. Moderate Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665).", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-476_1", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Architecture and Design Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values. Implementation Explicitly initialize all variables and other data stores, either during declaration or just before the first usage. Detection Methods: Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Moderate Manual Dynamic Analysis Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-476_2", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-480_0", "source": "CWE", "cwe_id": "CWE-480", "title": "Use of Incorrect Operator", "text": "Description: The product accidentally uses the wrong operator, which changes the logic in security-relevant ways. Extended Description: These types of errors are generally the result of a typo by the programmer. Consequences: Other Alter Execution Logic This weakness can cause unintended logic to be executed and other unexpected application behavior. Detection Methods: Automated Static Analysis This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program. Manual Static Analysis This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program.", "url": "https://cwe.mitre.org/data/definitions/480.html"}
{"id": "CWE-484_0", "source": "CWE", "cwe_id": "CWE-484", "title": "Omitted Break Statement in Switch", "text": "Description: The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition. Extended Description: This can lead to critical code executing in situations where it should not. Consequences: Other Alter Execution Logic This weakness can cause unintended logic to be executed and other unexpected application behavior. Mitigations: Implementation Omitting a break statement so that one may fall through is often indistinguishable from an error, and therefore should be avoided. If you need to use fall-through capabilities, make sure that you have clearly documented this within the switch statement, and ensure that you have examined all the logical possibilities. Implementation The functionality of omitting a break statement could be clarified with an if statement. This method is much safer. Detection Methods: White Box Omission of a break statement might be intentional, in order to support fallthrough. Automated detection methods might therefore be erroneous. Semantic understanding of expected product behavior is required to interpret whether the code is correct. Black Box Since this weakness is associated with a code construct, it would be indistinguishable from other errors that produce the same behavior.", "url": "https://cwe.mitre.org/data/definitions/484.html"}
{"id": "CWE-484_1", "source": "CWE", "cwe_id": "CWE-484", "title": "Omitted Break Statement in Switch", "text": "Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/484.html"}
{"id": "CWE-561_0", "source": "CWE", "cwe_id": "CWE-561", "title": "Dead Code", "text": "Description: The product contains dead code, which can never be executed. Extended Description: Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed. Consequences: Other Quality Degradation Dead code that results from code that can never be executed is an indication of problems with the source code that needs to be fixed and is an indication of poor quality. Other Reduce Maintainability Mitigations: Implementation Remove dead code before deploying the application. Testing Use a static analysis tool to spot dead code.", "url": "https://cwe.mitre.org/data/definitions/561.html"}
{"id": "CWE-561_1", "source": "CWE", "cwe_id": "CWE-561", "title": "Dead Code", "text": "Detection Methods: Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling High Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Binary / Bytecode Quality Analysis Compare binary / bytecode to application permission manifest High Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Automated Monitored Execution SOAR Partial Automated Static Analysis According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Permission Manifest Analysis SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source Code Quality Analyzer Cost effective for partial coverage: Warning Flags Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Dynamic Analysis with Automated Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High", "url": "https://cwe.mitre.org/data/definitions/561.html"}
{"id": "CWE-562_0", "source": "CWE", "cwe_id": "CWE-562", "title": "Return of Stack Variable Address", "text": "Description: A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash. Extended Description: Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced. Consequences: Availability Integrity Confidentiality Read Memory Modify Memory Execute Unauthorized Code or Commands DoS: Crash, Exit, or Restart If the returned stack buffer address is dereferenced after the return, then an attacker may be able to modify or read memory, depending on how the address is used. If the address is used for reading, then the address itself may be exposed, or the contents that the address points to. If the address is used for writing, this can lead to a crash and possibly code execution. Mitigations: Testing Use static analysis tools to spot return of the address of a stack variable.", "url": "https://cwe.mitre.org/data/definitions/562.html"}
{"id": "CWE-562_1", "source": "CWE", "cwe_id": "CWE-562", "title": "Return of Stack Variable Address", "text": "Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/562.html"}
{"id": "CWE-563_0", "source": "CWE", "cwe_id": "CWE-563", "title": "Assignment to Variable without Use", "text": "Description: The variable's value is assigned but never used, making it a dead store. Extended Description: After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug. Consequences: Other Quality Degradation Varies by Context This weakness could be an indication of a bug in the program or a deprecated variable that was not removed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses. Mitigations: Implementation Remove unused variables from the code. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/563.html"}
{"id": "CWE-570_0", "source": "CWE", "cwe_id": "CWE-570", "title": "Expression is Always False", "text": "Description: The product contains an expression that will always evaluate to false. Consequences: Other Quality Degradation Varies by Context Mitigations: Testing Use Static Analysis tools to spot such conditions. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/570.html"}
{"id": "CWE-571_0", "source": "CWE", "cwe_id": "CWE-571", "title": "Expression is Always True", "text": "Description: The product contains an expression that will always evaluate to true. Consequences: Other Quality Degradation Varies by Context Mitigations: Testing Use Static Analysis tools to spot such conditions. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/571.html"}
{"id": "CWE-590_0", "source": "CWE", "cwe_id": "CWE-590", "title": "Free of Memory not on the Heap", "text": "Description: The product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc(). Extended Description: When free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code. Consequences: Integrity Confidentiality Availability Execute Unauthorized Code or Commands Modify Memory There is the potential for arbitrary code execution with privileges of the vulnerable program via a \"write, what where\" primitive. If pointers to memory which hold user information are freed, a malicious user will be able to write 4 bytes anywhere in memory. Mitigations: Implementation Only free pointers that you have called malloc on previously. This is the recommended solution. Keep track of which pointers point at the beginning of valid chunks and free them only once. Implementation Before freeing a pointer, the programmer should make sure that the pointer was previously allocated on the heap and that the memory belongs to the programmer. Freeing an unallocated pointer will cause undefined behavior in the program.", "url": "https://cwe.mitre.org/data/definitions/590.html"}
{"id": "CWE-590_1", "source": "CWE", "cwe_id": "CWE-590", "title": "Free of Memory not on the Heap", "text": "Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers. Architecture and Design Use a language that provides abstractions for memory allocation and deallocation. Testing Use a tool that dynamically detects memory management problems, such as valgrind. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/590.html"}
{"id": "CWE-628_0", "source": "CWE", "cwe_id": "CWE-628", "title": "Function Call with Incorrectly Specified Arguments", "text": "Description: The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to always-incorrect behavior and resultant weaknesses. Extended Description: There are multiple ways in which this weakness can be introduced, including: the wrong variable or reference; an incorrect number of arguments; incorrect order of arguments; wrong type of arguments; or wrong value. Consequences: Other Access Control Quality Degradation Gain Privileges or Assume Identity This weakness can cause unintended behavior and can lead to additional weaknesses such as allowing an attacker to gain unintended access to system resources. Mitigations: Build and Compilation Once found, these issues are easy to fix. Use code inspection tools and relevant compiler features to identify potential violations. Pay special attention to code that is not likely to be exercised heavily during QA. Architecture and Design Make sure your API's are stable before you use them in production code. Detection Methods: Other Since these bugs typically introduce incorrect behavior that is obvious to users, they are found quickly, unless they occur in rarely-tested code paths. Managing the correct number of arguments can be made more difficult in cases where format strings are used, or when variable numbers of arguments are supported.", "url": "https://cwe.mitre.org/data/definitions/628.html"}
{"id": "CWE-667_0", "source": "CWE", "cwe_id": "CWE-667", "title": "Improper Locking", "text": "Description: The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors. Extended Description: Locking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc. Consequences: Availability DoS: Resource Consumption (CPU) Inconsistent locking discipline can lead to deadlock. Mitigations: Implementation Libraries or Frameworks Use industry standard APIs to implement locking mechanism. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/667.html"}
{"id": "CWE-675_0", "source": "CWE", "cwe_id": "CWE-675", "title": "Multiple Operations on Resource in Single-Operation Context", "text": "Description: The product performs the same operation on a resource two or more times, when the operation should only be applied once. Consequences: Other Other", "url": "https://cwe.mitre.org/data/definitions/675.html"}
{"id": "CWE-681_0", "source": "CWE", "cwe_id": "CWE-681", "title": "Incorrect Conversion between Numeric Types", "text": "Description: When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur. Consequences: Other Integrity Unexpected State Quality Degradation The program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability. Mitigations: Implementation Avoid making conversion between numeric types. Always check for the allowed ranges.", "url": "https://cwe.mitre.org/data/definitions/681.html"}
{"id": "CWE-703_0", "source": "CWE", "cwe_id": "CWE-703", "title": "Improper Check or Handling of Exceptional Conditions", "text": "Description: The product does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the product. Consequences: Confidentiality Availability Integrity Read Application Data DoS: Crash, Exit, or Restart Unexpected State Detection Methods: Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Fault Injection - source code Fault Injection - binary Cost effective for partial coverage: Forced Path Execution High Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer SOAR Partial Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction High", "url": "https://cwe.mitre.org/data/definitions/703.html"}
{"id": "CWE-764_0", "source": "CWE", "cwe_id": "CWE-764", "title": "Multiple Locks of a Critical Resource", "text": "Description: The product locks a critical resource more times than intended, leading to an unexpected state in the system. Extended Description: When a product is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE-412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible. Consequences: Availability Integrity DoS: Resource Consumption (CPU) DoS: Crash, Exit, or Restart Unexpected State Mitigations: Implementation When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.", "url": "https://cwe.mitre.org/data/definitions/764.html"}
{"id": "CWE-765_0", "source": "CWE", "cwe_id": "CWE-765", "title": "Multiple Unlocks of a Critical Resource", "text": "Description: The product unlocks a critical resource more times than intended, leading to an unexpected state in the system. Extended Description: When the product is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity. Consequences: Availability Integrity DoS: Crash, Exit, or Restart Modify Memory Unexpected State Mitigations: Implementation When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the product acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.", "url": "https://cwe.mitre.org/data/definitions/765.html"}
{"id": "CWE-786_0", "source": "CWE", "cwe_id": "CWE-786", "title": "Access of Memory Location Before Start of Buffer", "text": "Description: The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer. Extended Description: This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. Consequences: Confidentiality Read Memory For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences. Integrity Availability Modify Memory DoS: Crash, Exit, or Restart Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Integrity Modify Memory Execute Unauthorized Code or Commands If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs.", "url": "https://cwe.mitre.org/data/definitions/786.html"}
{"id": "CWE-786_1", "source": "CWE", "cwe_id": "CWE-786", "title": "Access of Memory Location Before Start of Buffer", "text": "Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/786.html"}
{"id": "CWE-824_0", "source": "CWE", "cwe_id": "CWE-824", "title": "Access of Uninitialized Pointer", "text": "Description: The product accesses or uses a pointer that has not been initialized. Extended Description: If the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks. Depending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed. Consequences: Confidentiality Read Memory If the uninitialized pointer is used in a read operation, an attacker might be able to read sensitive portions of memory. Availability DoS: Crash, Exit, or Restart If the uninitialized pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur.", "url": "https://cwe.mitre.org/data/definitions/824.html"}
{"id": "CWE-824_1", "source": "CWE", "cwe_id": "CWE-824", "title": "Access of Uninitialized Pointer", "text": "Integrity Confidentiality Availability Execute Unauthorized Code or Commands If the uninitialized pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/824.html"}
{"id": "CWE-825_0", "source": "CWE", "cwe_id": "CWE-825", "title": "Expired Pointer Dereference", "text": "Description: The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid. Extended Description: When a product releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the product to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution. Consequences: Confidentiality Read Memory If the expired pointer is used in a read operation, an attacker might be able to control data read in by the application. Availability DoS: Crash, Exit, or Restart If the expired pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur. Integrity Confidentiality Availability Execute Unauthorized Code or Commands If the expired pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible. Mitigations: Architecture and Design Choose a language that provides automatic memory management. Implementation When freeing pointers, be sure to set them to NULL once they are freed.", "url": "https://cwe.mitre.org/data/definitions/825.html"}
{"id": "CWE-825_1", "source": "CWE", "cwe_id": "CWE-825", "title": "Expired Pointer Dereference", "text": "However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.", "url": "https://cwe.mitre.org/data/definitions/825.html"}
{"id": "CWE-833_0", "source": "CWE", "cwe_id": "CWE-833", "title": "Deadlock", "text": "Description: The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock. Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Other) DoS: Crash, Exit, or Restart Each thread of execution will \"hang\" and prevent tasks from completing. In some cases, CPU consumption may occur if a lock check occurs in a tight loop.", "url": "https://cwe.mitre.org/data/definitions/833.html"}
{"id": "CWE-835_0", "source": "CWE", "cwe_id": "CWE-835", "title": "Loop with Unreachable Exit Condition ('Infinite Loop')", "text": "Description: The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop. Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Amplification An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory. The software's operation may slow down, or cause a long time to respond.", "url": "https://cwe.mitre.org/data/definitions/835.html"}
{"id": "CWE-843_0", "source": "CWE", "cwe_id": "CWE-843", "title": "Access of Resource Using Incompatible Type ('Type Confusion')", "text": "Description: The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type. Extended Description: When the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access. While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways. This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues. Consequences: Availability Integrity Confidentiality Read Memory Modify Memory Execute Unauthorized Code or Commands DoS: Crash, Exit, or Restart When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution.", "url": "https://cwe.mitre.org/data/definitions/843.html"}
{"id": "CWE-908_0", "source": "CWE", "cwe_id": "CWE-908", "title": "Use of Uninitialized Resource", "text": "Description: The product uses or accesses a resource that has not been initialized. Extended Description: When a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product. Consequences: Confidentiality Read Memory Read Application Data When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party. Availability DoS: Crash, Exit, or Restart The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend. Mitigations: Implementation Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all required steps. Implementation Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization. Implementation Avoid race conditions (CWE-362) during initialization routines. Build and Compilation Run or compile the product with settings that generate warnings about uninitialized variables or data.", "url": "https://cwe.mitre.org/data/definitions/908.html"}
{"id": "ARR30-C_pdf_0", "source": "CERT_PDF", "cert_rule": "ARR30-C", "title": "Do not form or use out-of-bounds pointers or array", "kind": "description", "text": "subscripts The C Standard identifies the following distinct situations in which undefined behavior (UB) can arise as a result of invalid pointer operations: UB Description Example Code 46 Addition or subtraction of a pointer Forming Out-of-Bounds Pointer, into, or just beyond, an array ob- Null Pointer Arithmetic ject and an integer type produces a result that does not point into, or just beyond, the same array ob- ject. 47 Addition or subtraction of a pointer Dereferencing Past the End into, or just beyond, an array ob- Pointer, Using Past the End Index ject and an integer type produces a result that points just beyond the array object and is used as the op- erand of a unary * operator that is evaluated. 49 An array subscript is out of range, Apparently Accessible Out-of- even if an object is apparently ac- Range Index cessible with the given subscript, for example, in the lvalue expres- sion a [1] [7] given the declaration int a [4] [5]). 62 An attempt is made to access, or Pointer Past Flexible Array Mem- generate a pointer to just past, a ber flexible array member of a struc- ture when the referenced object provides no elements for that ar- ray. 7.1.1"}
{"id": "ARR30-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c0.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\nenum { TABLESIZE = 100 };\n \nstatic int table[TABLESIZE];\n \nint *f(int index) {\n  if (index >= 0 && index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n"}
{"id": "ARR30-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c1.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\n#include <stddef.h>\n  \nenum { TABLESIZE = 100 };\n \nstatic int table[TABLESIZE];\n \nint *f(size_t index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n"}
{"id": "ARR30-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c2.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\nHRESULT GetMachineName(\n  wchar_t *pwszPath,\n  wchar_t wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  wchar_t *pwszServerName = wszMachineName;\n  wchar_t *pwszTemp = pwszPath + 2;\n  wchar_t *end_addr\n    = pwszServerName + MAX_COMPUTERNAME_LENGTH_FQDN;\n  while ((*pwszTemp != L'\\\\') &&\n         (*pwszTemp != L'\\0') &&\n         (pwszServerName < end_addr))\n  {\n    *pwszServerName++ = *pwszTemp++;\n  }\n \n  /* ... */\n}\n"}
{"id": "ARR30-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c3.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\n#include <stdint.h>\n#include <stdlib.h>\n  \nstatic int *table = NULL;\nstatic size_t size = 0;\n \nint insert_in_table(size_t pos, int value) {\n  if (size <= pos) {\n    if ((SIZE_MAX - 1 < pos) ||\n        ((pos + 1) > SIZE_MAX / sizeof(*table))) {\n      return -1;\n    }\n  \n    int *tmp = (int *)realloc(table, sizeof(*table) * (pos + 1));\n    if (tmp == NULL) {\n      return -1;\n    }\n    /* Modify size only after realloc() succeeds */\n    size  = pos + 1;\n    table = tmp;\n  }\n \n  table[pos] = value;\n  return 0;\n}\n"}
{"id": "ARR30-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c4.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\n#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n \nvoid init_matrix(int x) {\n  for (size_t i = 0; i < ROWS; i++) {\n    for (size_t j = 0; j < COLS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n"}
{"id": "ARR30-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c5.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution\n#include <stdlib.h>\n  \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n \nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n \n  while (first != last) { /* Avoid incrementing here */\n    if (*++first == (unsigned char)c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n  \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}\n"}
{"id": "ARR30-C_samples_c6.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/c6.c", "kind": "compliant", "text": "// ARR30-C: Compliant Solution  (Null Pointer Arithmetic)\n#include <string.h>\n#include <stdlib.h>\n \nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (NULL == buffer) {\n    /* Handle error */\n  }\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\n"}
{"id": "ARR30-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc0.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Forming Out-of-Bounds Pointer)\nenum { TABLESIZE = 100 };\n \nstatic int table[TABLESIZE];\n \nint *f(int index) {\n  if (index < TABLESIZE) {\n    return table + index;\n  }\n  return NULL;\n}\n"}
{"id": "ARR30-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc1.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Dereferencing Past-the-End Pointer)\nerror_status_t _RemoteActivation(\n      /* ... */, WCHAR *pwszObjectName, ... ) {\n   *phr = GetServerPath(\n              pwszObjectName, &pwszObjectName);\n    /* ... */\n}\n \nHRESULT GetServerPath(\n  WCHAR *pwszPath, WCHAR **pwszServerPath ){\n  WCHAR *pwszFinalPath = pwszPath;\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1];\n  hr = GetMachineName(pwszPath, wszMachineName);\n  *pwszServerPath = pwszFinalPath;\n}\n \nHRESULT GetMachineName(\n  WCHAR *pwszPath,\n  WCHAR wszMachineName[MAX_COMPUTERNAME_LENGTH_FQDN+1])\n{\n  pwszServerName = wszMachineName;\n  LPWSTR pwszTemp = pwszPath + 2;\n  while (*pwszTemp != L'\\\\')\n    *pwszServerName++ = *pwszTemp++;\n  /* ... */\n}\n"}
{"id": "ARR30-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc2.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Using Past-the-End Index)\n#include <stdlib.h>\n  \nstatic int *table = NULL;\nstatic size_t size = 0;\n \nint insert_in_table(size_t pos, int value) {\n  if (size < pos) {\n    int *tmp;\n    size = pos + 1;\n    tmp = (int *)realloc(table, sizeof(*table) * size);\n    if (tmp == NULL) {\n      return -1;   /* Failure */\n    }\n    table = tmp;\n  }\n \n  table[pos] = value;\n  return 0;\n}\n"}
{"id": "ARR30-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc3.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Apparently Accessible Out-of-Range Index)\n#include <stddef.h>\n#define COLS 5\n#define ROWS 7\nstatic int matrix[ROWS][COLS];\n \nvoid init_matrix(int x) {\n  for (size_t i = 0; i < COLS; i++) {\n    for (size_t j = 0; j < ROWS; j++) {\n      matrix[i][j] = x;\n    }\n  }\n}\n"}
{"id": "ARR30-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc4.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Pointer Past Flexible Array Member)\n#include <stdlib.h>\n  \nstruct S {\n  size_t len;\n  char buf[];  /* Flexible array member */\n};\n \nconst char *find(const struct S *s, int c) {\n  const char *first = s->buf;\n  const char *last  = s->buf + s->len;\n \n  while (first++ != last) { /* Undefined behavior */\n    if (*first == (unsigned char)c) {\n      return first;\n    }\n  }\n  return NULL;\n}\n  \nvoid g(void) {\n  struct S *s = (struct S *)malloc(sizeof(struct S));\n  if (s == NULL) {\n    /* Handle error */\n  }\n  s->len = 0;\n  find(s, 'a');\n}\n"}
{"id": "ARR30-C_samples_nc5.c", "source": "CERT_SAMPLES", "cert_rule": "ARR30-C", "file_path": "rules/arr/30/nc5.c", "kind": "noncompliant", "text": "// ARR30-C: Noncompliant Code Example (Null Pointer Arithmetic)\n#include <string.h>\n#include <stdlib.h>\n \nchar *init_block(size_t block_size, size_t offset,\n                 char *data, size_t data_size) {\n  char *buffer = malloc(block_size);\n  if (data_size > block_size || block_size - data_size < offset) {\n    /* Data won't fit in buffer, handle error */\n  }\n  memcpy(buffer + offset, data, data_size);\n  return buffer;\n}\n"}
{"id": "ARR36-C_pdf_0", "source": "CERT_PDF", "cert_rule": "ARR36-C", "title": "Do not subtract or compare two pointers that do not", "kind": "description", "text": "refer to the same array When two pointers are subtracted, both must point to elements of the same array object or just one past the last element of the array object (C Standard, 6.5.6 [ISO/IEC 9899:2011]); the result is the difference of the subscripts of the two array elements. Otherwise, the operation is undefined be- havior. (See undefined behavior 48.) Similarly, comparing pointers using the relational operators , , , and gives the positions of < <= >= > the pointers relative to each other. Subtracting or comparing pointers that do not refer to the same array is undefined behavior. (See undefined behavior 48 and undefined behavior 53.) Comparing pointers using the equality operators and has well-defined semantics regardless == != of whether or not either of the pointers is null, points into the same object, or points one past the last element of an array object or function. 7.3.1"}
{"id": "ARR36-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR36-C", "file_path": "rules/arr/36/c0.c", "kind": "compliant", "text": "// ARR36-C: Compliant Solution\n#include <stddef.h>\nenum { SIZE = 32 };\n  \nvoid func(void) {\n  int nums[SIZE];\n  int *next_num_ptr = nums;\n  size_t free_elements;\n \n  /* Increment next_num_ptr as array fills */\n \n  free_elements = &(nums[SIZE]) - next_num_ptr;\n}\n"}
{"id": "ARR36-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR36-C", "file_path": "rules/arr/36/nc0.c", "kind": "noncompliant", "text": "// ARR36-C: Noncompliant Code Example\n#include <stddef.h>\n  \nenum { SIZE = 32 };\n  \nvoid func(void) {\n  int nums[SIZE];\n  int end;\n  int *next_num_ptr = nums;\n  size_t free_elements;\n \n  /* Increment next_num_ptr as array fills */\n \n  free_elements = &end - next_num_ptr;\n}\n"}
{"id": "ARR37-C_pdf_0", "source": "CERT_PDF", "cert_rule": "ARR37-C", "title": "Do not add or subtract an integer to a pointer to a non-", "kind": "description", "text": "array object Pointer arithmetic must be performed only on pointers that reference elements of array objects. The C Standard, 6.5.6 [ISO/IEC 9899:2011], states the following about pointer arithmetic: When an expression that has integer type is added to or subtracted from a pointer, the result has the type of the pointer operand. If the pointer operand points to an element of an array object, and the array is large enough, the result points to an element offset from the original element such that the difference of the subscripts of the resulting and origi- nal array elements equals the integer expression. 7.4.1"}
{"id": "ARR37-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR37-C", "file_path": "rules/arr/37/c0.c", "kind": "compliant", "text": "// ARR37-C: Compliant Solution\ntotal = numb->num_a + numb->num_b + numb->num_c;\n"}
{"id": "ARR37-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "ARR37-C", "file_path": "rules/arr/37/c1.c", "kind": "compliant", "text": "// ARR37-C: Compliant Solution\n#include <stddef.h>\n \nstruct numbers {\n  short a[3];\n};\n \nint sum_numbers(const short *numb, size_t dim) {\n  int total = 0;\n  for (size_t i = 0; i < dim; ++i) {\n    total += numb[i];\n  }\n \n  return total;\n}\n \nint main(void) {\n  struct numbers my_numbers = { .a[0]= 1, .a[1]= 2, .a[2]= 3};\n  sum_numbers(\n    my_numbers.a,\n    sizeof(my_numbers.a)/sizeof(my_numbers.a[0])\n  );\n  return 0;\n}\n"}
{"id": "ARR37-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "ARR37-C", "file_path": "rules/arr/37/nc0.c", "kind": "noncompliant", "text": "// ARR37-C: Noncompliant Code Example\nstruct numbers {\n  short num_a, num_b, num_c;\n};\n \nint sum_numbers(const struct numbers *numb){\n  int total = 0;\n  const short *numb_ptr;\n \n  for (numb_ptr = &numb->num_a;\n       numb_ptr <= &numb->num_c;\n       numb_ptr++) {\n    total += *(numb_ptr);\n  }\n \n  return total;\n}\n \nint main(void) {\n  struct numbers my_numbers = { 1, 2, 3 };\n  sum_numbers(&my_numbers);\n  return 0;\n}\n"}
{"id": "CON33-C_pdf_0", "source": "CERT_PDF", "cert_rule": "CON33-C", "title": "Avoid race conditions when using library functions", "kind": "description", "text": "Some C standard library functions are not guaranteed to be reentrant with respect to threads. Functions such as and return a pointer to the result stored in function-allo- strtok() asctime() cated memory on a per-process basis. Other functions such as store state information in rand() function-allocated memory on a per-process basis. Multiple threads invoking the same function can cause concurrency problems, which often result in abnormal behavior and can cause more se- rious vulnerabilities, such as abnormal termination, denial-of-service attack, and data integrity vi- olations. According to the C Standard, the library functions listed in the following table may contain data races when invoked by multiple threads. Functions Remediation , MSC30-C. Do not use the rand() function for rand() srand() generating pseudorandom numbers , ENV34-C."}
{"id": "CON33-C_pdf_1", "source": "CERT_PDF", "cert_rule": "CON33-C", "title": "Avoid race conditions when using library functions", "kind": "description", "text": "Do not store pointers returned by getenv() getenv_s() certain functions in C11 Annex K strtok() strtok_s() in POSIX strtok_r() in C11 Annex K strerror() strerror_s() in POSIX strerror_r() , , , , asctime() ctime() asctime_s() ctime_s() local- , , in C11 Annex K localtime() gmtime() time_s() gmtime_s() Protect multithreaded access to locale-specific setlocale() functions with a mutex , Do not attempt to initialize an atomic variable ATOMIC_VAR_INIT atomic_init() from multiple threads in C11 Annex K tmpnam() tmpnam_s() in POSIX tmpnam_r() , , Do not call with a null argu- mbrtoc16() c16rtomb() mbstate_t * , ment mbrtoc32() c32rtomb() Section 2.9.1 of the Portable Operating System Interface (POSIX), Base Specifications, Issue 7 [IEEE Std 1003.1:2013] extends the list of functions that are not required to be thread-safe. 14.4.1"}
{"id": "CON33-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "CON33-C", "file_path": "rules/con/33/c0.c", "kind": "compliant", "text": "// CON33-C: Compliant Solution (Annex K, strerror_s()) \n#define __STDC_WANT_LIB_EXT1__ 1\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n  \nenum { BUFFERSIZE = 64 };\nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_s(errmsg, BUFFERSIZE, errno) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"}
{"id": "CON33-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "CON33-C", "file_path": "rules/con/33/c1.c", "kind": "compliant", "text": "// CON33-C: Compliant Solution (POSIX, strerror_r())\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n \nenum { BUFFERSIZE = 64 };\n  \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char errmsg[BUFFERSIZE];\n    if (strerror_r(errno, errmsg, BUFFERSIZE) != 0) {\n      /* Handle error */\n    }\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"}
{"id": "CON33-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "CON33-C", "file_path": "rules/con/33/nc0.c", "kind": "noncompliant", "text": "// CON33-C: Noncompliant Code Example\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n  \nvoid f(FILE *fp) {\n  fpos_t pos;\n  errno = 0;\n \n  if (0 != fgetpos(fp, &pos)) {\n    char *errmsg = strerror(errno);\n    printf(\"Could not get the file position: %s\\n\", errmsg);\n  }\n}\n"}
{"id": "CON34-C_pdf_0", "source": "CERT_PDF", "cert_rule": "CON34-C", "title": "Declare objects shared between threads with", "kind": "description", "text": "appropriate storage durations Accessing the automatic or thread-local variables of one thread from another thread is implemen- tation-defined behavior and can cause invalid memory accesses because the execution of threads can be interwoven within the constraints of the synchronization model. As a result, the referenced stack frame or thread-local variable may no longer be valid when another thread tries to access it. Shared static variables can be protected by thread synchronization mechanisms. However, automatic (local) variables cannot be shared in the same manner because the referenced stack frames thread would need to stop executing, or some other mechanism must be employed to ensure that the referenced stack frame is still valid. Do not access automatic or thread-local ob- jects from a thread other than the one with which the object is associated. See DCL30-C. Declare objects with appropriate storage durations for information on how to declare objects with appro- priate storage durations when data is not being shared between threads. 14.5.1"}
{"id": "CON34-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/c0.c", "kind": "compliant", "text": "// CON34-C: Compliant Solution (Static Storage Duration)\n#include <threads.h>\n#include <stdio.h>\n \nint child_thread(void *v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n  \nvoid create_thread(thrd_t *tid) {\n  static int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n  \nint main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n"}
{"id": "CON34-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/c1.c", "kind": "compliant", "text": "// CON34-C: Compliant Solution (Allocated Storage Duration)\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nint child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n  \nvoid create_thread(thrd_t *tid, int *value) {\n  *value = 1;\n  if (thrd_success != thrd_create(tid, child_thread,\n                                  value)) {\n    /* Handle error */\n  }\n}\n  \nint main(void) {\n  thrd_t tid;\n  int *value = (int *)malloc(sizeof(int));\n  if (!value) {\n    /* Handle error */\n  }\n  create_thread(&tid, value);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  free(value);\n  return 0;\n}\n"}
{"id": "CON34-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/c2.c", "kind": "compliant", "text": "// CON34-C: Compliant Solution (Thread-Specific Storage)\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n \nstatic tss_t key;\n \nint child_thread(void *v) {\n  int *result = v;\n  printf(\"Result: %d\\n\", *result); /* Correctly prints 1 */\n  return 0;\n}\n \nint create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  /* ... */\n  void *v = tss_get(key);\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                   child_thread, v)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  thrd_t parent_tid, child_tid;\n \n  if (thrd_success != tss_create(&key, free)) {\n  /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\nreturn 0;\n} \n"}
{"id": "CON34-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/c3.c", "kind": "compliant", "text": "// CON34-C: Compliant Solution (Thread-Local Storage, Windows, Visual Studio)\n#include <Windows.h>\n#include <stdio.h>\n \nDWORD WINAPI child_thread(LPVOID v) {\n  int *result = (int *)v;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return NULL;\n}\n \nint create_thread(HANDLE *tid) {\n  /* Declare val as a thread-local value */\n  __declspec(thread) int val = 1;\n  *tid = create_thread(NULL, 0, child_thread, &val, 0, NULL);\n  return *tid == NULL;\n}\n \nint main(void) {\n  HANDLE tid;\n  \n  if (create_thread(&tid)) {\n    /* Handle error */\n  }\n  \n  if (WAIT_OBJECT_0 != WaitForSingleObject(tid, INFINITE)) {\n    /* Handle error */\n  }\n  CloseHandle(tid);\n  \n  return 0;\n}\n"}
{"id": "CON34-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/c4.c", "kind": "compliant", "text": "// CON34-C: Compliant Solution (OpenMP, parallel, private)\n#include <omp.h>\n#include <stdio.h>\n \nint main(void) {\n  int j = 0;\n  #pragma omp parallel private(j)\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++;\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}\n"}
{"id": "CON34-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/nc0.c", "kind": "noncompliant", "text": "// CON34-C: Noncompliant Code Example (Automatic Storage Duration)\n#include <threads.h>\n#include <stdio.h>\n \nint child_thread(void *val) {\n  int *res = (int *)val;\n  printf(\"Result: %d\\n\", *res);\n  return 0;\n}\n \nvoid create_thread(thrd_t *tid) {\n  int val = 1;\n  if (thrd_success != thrd_create(tid, child_thread, &val)) {\n    /* Handle error */\n  }\n}\n \nint main(void) {\n  thrd_t tid;\n  create_thread(&tid);\n   \n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n"}
{"id": "CON34-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/nc1.c", "kind": "noncompliant", "text": "// CON34-C: Noncompliant Code Example (Automatic Storage Duration)\n#include <threads.h>\n#include <stdio.h>\n \nint child_thread(void *val) {\n  int *result = (int *)val;\n  printf(\"Result: %d\\n\", *result);  /* Correctly prints 1 */\n  return 0;\n}\n  \nvoid create_thread(thrd_t *tid, int *val) {\n  if (thrd_success != thrd_create(tid, child_thread, val)) {\n    /* Handle error */\n  }\n}\n  \nint main(void) {\n  int val = 1;\n  thrd_t tid;\n  create_thread(&tid, &val);\n  if (thrd_success != thrd_join(tid, NULL)) {\n    /* Handle error */\n  }\n  return 0;\n}\n"}
{"id": "CON34-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/nc2.c", "kind": "noncompliant", "text": "// CON34-C: Noncompliant Code Example (Thread-Specific Storage)\n#include <threads.h>\n#include <stdio.h>\n#include <stdlib.h>\n  \nstatic tss_t key;\n  \nint child_thread(void *v) {\n  void *result = tss_get(*(tss_t *)v);\n  printf(\"Result: %d\\n\", *(int *)result);\n  return 0;\n}\n  \nint create_thread(void *thrd) {\n  int *val = (int *)malloc(sizeof(int));\n  if (val == NULL) {\n    /* Handle error */\n  }\n  *val = 1;\n  if (thrd_success != tss_set(key, val)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create((thrd_t *)thrd,\n                                  child_thread, &key)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  thrd_t parent_tid, child_tid;\n \n  if (thrd_success != tss_create(&key, free)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_create(&parent_tid, create_thread,\n                                  &child_tid)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(parent_tid, NULL)) {\n    /* Handle error */\n  }\n  if (thrd_success != thrd_join(child_tid, NULL)) {\n    /* Handle error */\n  }\n  tss_delete(key);\n  return 0;\n} \n"}
{"id": "CON34-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "CON34-C", "file_path": "rules/con/34/nc3.c", "kind": "noncompliant", "text": "// CON34-C: Noncompliant Code Example (OpenMP, parallel)\n#include <omp.h>\n#include <stdio.h>\n  \nint main(void) {\n  int j = 0;\n  #pragma omp parallel\n  {\n    int t = omp_get_thread_num();\n    printf(\"Running thread - %d\\n\", t);\n    for (int i = 0; i < 5050; i++) {\n    j++; /* j not private; could be a race condition */\n    }\n    printf(\"Just ran thread - %d\\n\", t);\n    printf(\"loop count %d\\n\", j);\n  }\nreturn 0;\n}\n"}
{"id": "CON35-C_pdf_0", "source": "CERT_PDF", "cert_rule": "CON35-C", "title": "Avoid deadlock by locking in a predefined order", "kind": "description", "text": "Mutexes are used to prevent multiple threads from causing a data race by accessing shared re- sources at the same time. Sometimes, when locking mutexes, multiple threads hold each others lock, and the program consequently deadlocks. Four conditions are required for deadlock to oc- cur:  Mutual exclusion  Hold and wait  No preemption  Circular wait Deadlock needs all four conditions, so preventing deadlock requires preventing any one of the four conditions. One simple solution is to lock the mutexes in a predefined order, which prevents circular wait. 14.6.1"}
{"id": "CON35-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "CON35-C", "file_path": "rules/con/35/c0.c", "kind": "compliant", "text": "// CON35-C: Compliant Solution\n#include <stdlib.h>\n#include <threads.h>\n  \ntypedef struct {\n  int balance;\n  mtx_t balance_mutex;\n  \n  /* Should not change after initialization */\n  unsigned int id;\n} bank_account;\n \ntypedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n \nunsigned int global_id = 1;\n \nvoid create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n \n  nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n \n  nba->id = global_id++;\n  *ba = nba;\n}\n \nint deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n  int result = -1;\n  mtx_t *first;\n  mtx_t *second;\n \n  if (args->from->id == args->to->id) {\n    return -1; /* Indicate error */\n  }\n \n  /* Ensure proper ordering for locking */\n  if (args->from->id < args->to->id) {\n    first = &args->from->balance_mutex;\n    second = &args->to->balance_mutex;\n  } else {\n    first = &args->to->balance_mutex;\n    second = &args->from->balance_mutex;\n  }\n  if (thrd_success != mtx_lock(first)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_lock(second)) {\n    /* Handle error */\n  }\n \n  /* Not enough balance to transfer */\n  if (args->from->balance >= args->amount) {\n    args->from->balance -= args->amount;\n    args->to->balance += args->amount;\n    result = 0;\n  }\n \n  if (thrd_success != mtx_unlock(second)) {\n    /* Handle error */\n  }\n  if (thrd_success != mtx_unlock(first)) {\n    /* Handle error */\n  }\n  free(ptr);\n  return result;\n} \n"}
{"id": "CON35-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "CON35-C", "file_path": "rules/con/35/nc0.c", "kind": "noncompliant", "text": "// CON35-C: Noncompliant Code Example\n#include <stdlib.h>\n#include <threads.h>\n  \ntypedef struct {\n  int balance;\n  mtx_t balance_mutex;\n} bank_account;\n \ntypedef struct {\n  bank_account *from;\n  bank_account *to;\n  int amount;\n} transaction;\n \nvoid create_bank_account(bank_account **ba,\n                         int initial_amount) {\n  bank_account *nba = (bank_account *)malloc(\n    sizeof(bank_account)\n  );\n  if (nba == NULL) {\n    /* Handle error */\n  }\n \n  nba->balance = initial_amount;\n  if (thrd_success\n      != mtx_init(&nba->balance_mutex, mtx_plain)) {\n    /* Handle error */\n  }\n \n  *ba = nba;\n}\n \nint deposit(void *ptr) {\n  transaction *args = (transaction *)ptr;\n \n  if (thrd_success != mtx_lock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n \n  /* Not enough balance to transfer */\n  if (args->from->balance < args->amount) {\n    if (thrd_success\n        != mtx_unlock(&args->from->balance_mutex)) {\n      /* Handle error */\n    }\n    return -1; /* Indicate error */\n  }\n  if (thrd_success != mtx_lock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n \n  args->from->balance -= args->amount;\n  args->to->balance += args->amount;\n \n  if (thrd_success\n      != mtx_unlock(&args->from->balance_mutex)) {\n    /* Handle error */\n  }\n \n  if (thrd_success\n      != mtx_unlock(&args->to->balance_mutex)) {\n    /* Handle error */\n  }\n \n  free(ptr);\n  return 0;\n}\n \nint main(void) {\n  thrd_t thr1, thr2;\n  transaction *arg1;\n  transaction *arg2;\n  bank_account *ba1;\n  bank_account *ba2;\n \n  create_bank_account(&ba1, 1000);\n  create_bank_account(&ba2, 1000);\n \n  arg1 = (transaction *)malloc(sizeof(transaction));\n  if (arg1 == NULL) {\n    /* Handle error */\n  }\n  arg2 = (transaction *)malloc(sizeof(transaction));\n  if (arg2 == NULL) {\n    /* Handle error */\n  }\n  arg1->from = ba1;\n  arg1->to = ba2;\n  arg1->amount = 100;\n \n  arg2->from = ba2;\n  arg2->to = ba1;\n  arg2->amount = 100;\n \n  /* Perform the deposits */\n  if (thrd_success\n     != thrd_create(&thr1, deposit, (void *)arg1)) {\n    /* Handle error */\n  }\n  if (thrd_success\n      != thrd_create(&thr2, deposit, (void *)arg2)) {\n    /* Handle error */\n  }\n  return 0;\n} \n"}
{"id": "CON38-C_pdf_0", "source": "CERT_PDF", "cert_rule": "CON38-C", "title": "Preserve thread safety and liveness when using", "kind": "description", "text": "condition variables Both thread safety and liveness are concerns when using condition variables. The thread-safety property requires that all objects maintain consistent states in a multithreaded environment [Lea 2000]. The liveness property requires that every operation or function invocation execute to com- pletion without interruption; for example, there is no deadlock. Condition variables must be used inside a loop. (See CON36-C. Wrap functions that can while spuriously wake up in a loop for more information.) To guarantee liveness, programs must test the loop condition before invoking the function. This early test checks whether while cnd_wait() another thread has already satisfied the condition predicate and has sent a notification. Invoking the function after the notification has been sent results in indefinite blocking. cnd_wait() To guarantee thread safety, programs must test the loop condition after returning from the while function. When a given thread invokes the function, it will attempt to cnd_wait() cnd_wait() block until its condition variable is signaled by a call to or to cnd_broadcast() cnd_sig- . nal() The function unblocks one of the threads that are blocked on the specified condi- cnd_signal() tion variable at the time of the call. If multiple threads are waiting on the same condition variable, the scheduler can select any of those threads to be awakened (assuming that all threads have the same priority level)."}
{"id": "CON38-C_pdf_1", "source": "CERT_PDF", "cert_rule": "CON38-C", "title": "Preserve thread safety and liveness when using", "kind": "description", "text": "The function unblocks all of the threads that are blocked cnd_broadcast() on the specified condition variable at the time of the call. The order in which threads execute fol- lowing a call to is unspecified. Consequently, an unrelated thread could start cnd_broadcast() executing, discover that its condition predicate is satisfied, and resume execution even though it was supposed to remain dormant. For these reasons, threads must check the condition predicate after the function returns. A loop is the best choice for checking the condi- cnd_wait() while tion predicate both before and after invoking . cnd_wait() The use of is safe if each thread uses a unique condition variable. If multiple cnd_signal() threads share a condition variable, the use of is safe only if the following condi- cnd_signal() tions are met:  All threads must perform the same set of operations after waking up, which means that any thread can be selected to wake up and resume for a single invocation of . cnd_signal()  Only one thread is required to wake upon receiving the signal. The function can be used to unblock all of the threads that are blocked on the cnd_broadcast() specified condition variable if the use of is unsafe. cnd_signal() 14.9.1"}
{"id": "CON38-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "CON38-C", "file_path": "rules/con/38/c0.c", "kind": "compliant", "text": "// CON38-C: Compliant Solution (cnd_broadcast())\n#include <stdio.h>\n#include <threads.h>\n \nmtx_t mutex;\ncnd_t cond;\nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n \n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n \n  printf(\"Thread %zu has the lock\\n\", my_step);\n \n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n \n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n \n  printf(\"Thread %zu woke up\\n\", my_step);\n  }\n \n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n \n  current_step++;\n \n  /* Signal ALL waiting tasks */\n  if (thrd_success != cnd_broadcast(&cond)) {\n    /* Handle error */\n  }\n \n  printf(\"Thread %zu is exiting...\\n\", my_step);\n \n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n"}
{"id": "CON38-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "CON38-C", "file_path": "rules/con/38/c1.c", "kind": "compliant", "text": "// CON38-C: Compliant Solution (Using cnd_signal() with a Unique Condition Variable per Thread)\n#include <stdio.h>\n#include <threads.h>\n \nenum { NTHREADS = 5 };\n \nmtx_t mutex;\ncnd_t cond[NTHREADS];\n \nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n \n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n \n  printf(\"Thread %zu has the lock\\n\", my_step);\n \n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n \n    if (thrd_success != cnd_wait(&cond[my_step], &mutex)) {\n      /* Handle error */\n    }\n \n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n \n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n \n  current_step++;\n \n  /* Signal next step thread */\n  if ((my_step + 1) < NTHREADS) {\n    if (thrd_success != cnd_signal(&cond[my_step + 1])) {\n      /* Handle error */\n    }\n  }\n \n  printf(\"Thread %zu is exiting...\\n\", my_step);\n \n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\n \nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n \n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n \n  for (size_t i = 0; i< NTHREADS; ++i) {\n    if (thrd_success != cnd_init(&cond[i])) {\n      /* Handle error */\n    }\n  }\n \n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n \n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n \n  mtx_destroy(&mutex);\n \n  for (size_t i = 0; i < NTHREADS; ++i) {\n    cnd_destroy(&cond[i]);\n  }\n  return 0;\n}\n"}
{"id": "CON38-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "CON38-C", "file_path": "rules/con/38/c2.c", "kind": "compliant", "text": "// CON38-C: Compliant Solution (Windows, Condition Variables)\n#include <Windows.h>\n#include <stdio.h>\n  \nCRITICAL_SECTION lock;\nCONDITION_VARIABLE cond;\n  \nDWORD WINAPI run_step(LPVOID t) {\n  static size_t current_step = 0;\n  size_t my_step = (size_t)t;\n \n  EnterCriticalSection(&lock); \n  printf(\"Thread %zu has the lock\\n\", my_step);\n \n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n  \n    if (!SleepConditionVariableCS(&cond, &lock, INFINITE)) {\n      /* Handle error */\n    }\n \n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n \n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n \n  current_step++;\n  \n  LeaveCriticalSection(&lock);\n  \n  /* Signal ALL waiting tasks */\n  WakeAllConditionVariable(&cond);\n  \n  printf(\"Thread %zu is exiting...\\n\", my_step);\n  return 0;\n}\n  \nenum { NTHREADS = 5 };\n  \nint main(void) {\n  HANDLE threads[NTHREADS];\n   \n  InitializeCriticalSection(&lock);\n  InitializeConditionVariable(&cond);\n  \n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    threads[i] = CreateThread(NULL, 0, run_step, (LPVOID)i, 0, NULL);\n  }\n  \n  /* Wait for all threads to complete */\n  WaitForMultipleObjects(NTHREADS, threads, TRUE, INFINITE);\n  \n  DeleteCriticalSection(&lock);\n  \n  return 0;\n}\n"}
{"id": "CON38-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "CON38-C", "file_path": "rules/con/38/nc0.c", "kind": "noncompliant", "text": "// CON38-C: Noncompliant Code Example (cnd_signal())\n#include <stdio.h>\n#include <threads.h>\n \nenum { NTHREADS = 5 };\n \nmtx_t mutex;\ncnd_t cond;\n \nint run_step(void *t) {\n  static size_t current_step = 0;\n  size_t my_step = *(size_t *)t;\n \n  if (thrd_success != mtx_lock(&mutex)) {\n    /* Handle error */\n  }\n \n  printf(\"Thread %zu has the lock\\n\", my_step);\n  while (current_step != my_step) {\n    printf(\"Thread %zu is sleeping...\\n\", my_step);\n \n    if (thrd_success != cnd_wait(&cond, &mutex)) {\n      /* Handle error */\n    }\n \n    printf(\"Thread %zu woke up\\n\", my_step);\n  }\n  /* Do processing ... */\n  printf(\"Thread %zu is processing...\\n\", my_step);\n  current_step++;\n \n  /* Signal awaiting task */\n  if (thrd_success != cnd_signal(&cond)) {\n    /* Handle error */\n  }\n \n  printf(\"Thread %zu is exiting...\\n\", my_step);\n \n  if (thrd_success != mtx_unlock(&mutex)) {\n    /* Handle error */\n  }\n  return 0;\n}\nint main(void) {\n  thrd_t threads[NTHREADS];\n  size_t step[NTHREADS];\n \n  if (thrd_success != mtx_init(&mutex, mtx_plain)) {\n    /* Handle error */\n  }\n \n  if (thrd_success != cnd_init(&cond)) {\n    /* Handle error */\n  }\n \n  /* Create threads */\n  for (size_t i = 0; i < NTHREADS; ++i) {\n    step[i] = i;\n \n    if (thrd_success != thrd_create(&threads[i], run_step,\n                                    &step[i])) {\n      /* Handle error */\n    }\n  }\n \n  /* Wait for all threads to complete */\n  for (size_t i = NTHREADS; i != 0; --i) {\n    if (thrd_success != thrd_join(threads[i-1], NULL)) {\n      /* Handle error */\n    }\n  }\n \n  mtx_destroy(&mutex);\n  cnd_destroy(&cond);\n  return 0;\n} \n"}
{"id": "CON43-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/c0.c", "kind": "compliant", "text": "// CON43-C: Compliant Solution (Mutex)\n#include <threads.h>\n \nstatic int account_balance;\nstatic mtx_t account_lock;\n  \nint debit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance -= amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n \nint credit(int amount) {\n  if (mtx_lock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  account_balance += amount;\n  if (mtx_unlock(&account_lock) == thrd_error) {\n    return -1;   /* Indicate error to caller */\n  }\n  return 0;   /* Indicate success */\n}\n  \nint main(void) {\n  if(mtx_init(&account_lock, mtx_plain) == thrd_error) {\n    /* Handle error */\n  }\n  /* ... */\n}\n"}
{"id": "CON43-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/c1.c", "kind": "compliant", "text": "// CON43-C: Compliant Solution (Atomic)\n#include <stdatomic.h>\n \natomic_int account_balance;\n \nvoid debit(int amount) {\n  account_balance -= amount;\n}\n \nvoid credit(int amount) {\n  account_balance += amount;\n}\n"}
{"id": "CON43-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/c2.c", "kind": "compliant", "text": "// CON43-C: Compliant Solution (C11, Atomic)\n#include <stdio.h>\n#include <stdatomic.h>\n  \nvoid doStuff(atomic_int *ps) {\n  switch (atomic_load(ps)) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n"}
{"id": "CON43-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/c3.c", "kind": "compliant", "text": "// CON43-C: Compliant Solution (C11, Fences)\n#include <stdio.h>\n#include <stdatomic.h>\n  \nvoid doStuff(int *ps) {\n  atomic_thread_fence(memory_order_acquire);\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n  atomic_thread_fence(memory_order_release);\n}\n"}
{"id": "CON43-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/nc0.c", "kind": "noncompliant", "text": "// CON43-C: Noncompliant Code Example\nstatic volatile int account_balance;\n \nvoid debit(int amount) {\n  account_balance -= amount;\n}\n \nvoid credit(int amount) {\n  account_balance += amount;\n}\n"}
{"id": "CON43-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/nc1.c", "kind": "noncompliant", "text": "// CON43-C: Noncompliant Code Example (Double-Fetch)\n#include <stdio.h>\n  \nvoid doStuff(int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n"}
{"id": "CON43-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "CON43-C", "file_path": "rules/con/43/nc2.c", "kind": "noncompliant", "text": "// CON43-C: Noncompliant Code Example (Volatile)\n#include <stdio.h>\n  \nvoid doStuff(volatile int *ps) {\n  switch (*ps) {\n    case 0: { printf(\"0\"); break; }\n    case 1: { printf(\"1\"); break; }\n    case 2: { printf(\"2\"); break; }\n    case 3: { printf(\"3\"); break; }\n    case 4: { printf(\"4\"); break; }\n    default: { printf(\"default\"); break; }\n  }\n}\n"}
{"id": "DCL30-C_pdf_0", "source": "CERT_PDF", "cert_rule": "DCL30-C", "title": "Declare objects with appropriate storage durations", "kind": "description", "text": "Every object has a storage duration that determines its lifetime: static, thread, automatic, or allo- cated. According to the C Standard, 6.2.4, paragraph 2 [ISO/IEC 9899:2011], The lifetime of an object is the portion of program execution during which storage is guaranteed to be reserved for it. An object exists, has a constant address, and retains its last-stored value throughout its lifetime. If an object is referred to outside of its lifetime, the behavior is undefined. The value of a pointer becomes indeterminate when the ob- ject it points to reaches the end of its lifetime. Do not attempt to access an object outside of its lifetime. Attempting to do so is undefined behav- ior and can lead to an exploitable vulnerability. (See also undefined behavior 9 in the C Standard, Annex J.) 3.1.1"}
{"id": "DCL30-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/c0.c", "kind": "compliant", "text": "// DCL30-C: Compliant Solution (Same Storage Durations)\nvoid this_is_OK(void) {\n  const char c_str[] = \"Everything OK\";\n  const char *p = c_str;\n  /* ... */\n}\n/* p is inaccessible outside the scope of string c_str */\n"}
{"id": "DCL30-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/c1.c", "kind": "compliant", "text": "// DCL30-C: Compliant Solution (Differing Storage Durations)\nconst char *p;\nvoid is_this_OK(void) {\n  const char c_str[] = \"Everything OK?\";\n  p = c_str;\n  /* ... */\n  p = NULL;\n}\n"}
{"id": "DCL30-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/c2.c", "kind": "compliant", "text": "// DCL30-C: Compliant Solution (Return Values)\n#include <stddef.h>\nvoid init_array(char *array, size_t len) {\n  /* Initialize array */\n  return;\n}\n \nint main(void) {\n  char array[10];\n  init_array(array, sizeof(array) / sizeof(array[0]));\n  /* ... */\n  return 0;\n}\n"}
{"id": "DCL30-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/c3.c", "kind": "compliant", "text": "// DCL30-C: Compliant Solution (Output Parameter)\nchar local[10];\n  \nvoid squirrel_away(char **ptr_param) {\n  /* Initialize array */\n  *ptr_param = local;\n}\n \nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is valid in this scope */\n}\n"}
{"id": "DCL30-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/nc0.c", "kind": "noncompliant", "text": "// DCL30-C: Noncompliant Code Example (Differing Storage Durations)\n#include <stdio.h>\n  \nconst char *p;\nvoid dont_do_this(void) {\n  const char c_str[] = \"This will change\";\n  p = c_str; /* Dangerous */\n}\n \nvoid innocuous(void) {\n  printf(\"%s\\n\", p);\n}\n \nint main(void) {\n  dont_do_this();\n  innocuous();\n  return 0;\n}\n"}
{"id": "DCL30-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/nc1.c", "kind": "noncompliant", "text": "// DCL30-C: Noncompliant Code Example (Return Values)\nchar *init_array(void) {\n  char array[10];\n  /* Initialize array */\n  return array;\n}\n"}
{"id": "DCL30-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "DCL30-C", "file_path": "rules/dcl/30/nc2.c", "kind": "noncompliant", "text": "// DCL30-C: Noncompliant Code Example (Output Parameter)\nvoid squirrel_away(char **ptr_param) {\n  char local[10];\n  /* Initialize array */\n  *ptr_param = local;\n}\n \nvoid rodent(void) {\n  char *ptr;\n  squirrel_away(&ptr);\n  /* ptr is live but invalid here */\n}\n"}
{"id": "DCL40-C_pdf_0", "source": "CERT_PDF", "cert_rule": "DCL40-C", "title": "Do not create incompatible declarations of the same", "kind": "description", "text": "function or object Two or more incompatible declarations of the same function or object must not appear in the same program because they result in undefined behavior. The C Standard, 6.2.7, mentions that two types may be distinct yet compatible and addresses precisely when two distinct types are compatible. The C Standard identifies four situations in which undefined behavior (UB) may arise as a result of incompatible declarations of the same function or object: UB Description Code 15 Two declarations of the same All noncompliant code in this object or function specify types guideline that are not compatible (6.2.7). 31 Two identifiers differ only in non- Excessively Long Identifiers significant characters (6.4.2.1). 37 An object has its stored value Incompatible Object Declarations accessed other than by an lvalue Incompatible Array Declarations of an allowable type (6.5). 41 A function is defined with a type Incompatible Function Declara- that is not compatible with the tions type (of the expression) pointed Excessively Long Identifiers to by the expression that de- notes the called function (6.5.2.2). Although the effect of two incompatible declarations simply appearing in the same program may be benign on most implementations, the effects of invoking a function through an expression whose type is incompatible with the function definition are typically catastrophic."}
{"id": "DCL40-C_pdf_1", "source": "CERT_PDF", "cert_rule": "DCL40-C", "title": "Do not create incompatible declarations of the same", "kind": "description", "text": "Similarly, the effects of accessing an object using an lvalue of a type that is incompatible with the object defini- tion may range from unintended information exposure to memory overwrite to a hardware trap. 3.7.1"}
{"id": "DCL40-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/c0.c", "kind": "compliant", "text": "// DCL40-C: Compliant Solution (Incompatible Object Declarations)\n/* In a.c */\nextern int i;  \n \nint f(void) {\n  return ++i;  \n}\n \n/* In b.c */\nint i;\n"}
{"id": "DCL40-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/c1.c", "kind": "compliant", "text": "// DCL40-C: Compliant Solution (Incompatible Array Declarations)\n/* In a.c */\nextern int a[];  \n \nint f(unsigned int i, int x) {\n  int tmp = a[i];  \n  a[i] = x;        \n  return tmp;\n}\n \n/* In b.c */\nint a[] = { 1, 2, 3, 4 };\n"}
{"id": "DCL40-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/c2.c", "kind": "compliant", "text": "// DCL40-C: Compliant Solution (Incompatible Function Declarations)\n/* In a.c */\nextern int f(int a);  \n \nint g(int a) {\n  return f(a);  \n}\n \n/* In b.c */\nint f(int a) {  \n  return a * 2;\n}\n"}
{"id": "DCL40-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/c3.c", "kind": "compliant", "text": "// DCL40-C: Compliant Solution (Incompatible Variadic Function Declarations)\n/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n \n/* In b.c */\nvoid buginf(const char *fmt, ...);\n"}
{"id": "DCL40-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/c4.c", "kind": "compliant", "text": "// DCL40-C: Compliant Solution (Excessively Long Identifiers)\n/* In bashline.h */\nextern char * bash_groupname_completion(const char *, int);  \n \n/* In a.c */\n#include \"bashline.h\"\n \nvoid f(const char *s, int i) {\n  bash_groupname_completion(s, i); \n}\n \n/* In b.c */\nint bash_groupname_completion_funct;\n"}
{"id": "DCL40-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/nc0.c", "kind": "noncompliant", "text": "// DCL40-C: Noncompliant Code Example (Incompatible Object Declarations)\n/* In a.c */\nextern int i;   /* UB 15 */\n \nint f(void) {\n  return ++i;   /* UB 37 */\n}\n \n/* In b.c */\nshort i;   /* UB 15 */\n"}
{"id": "DCL40-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/nc1.c", "kind": "noncompliant", "text": "// DCL40-C: Noncompliant Code Example (Incompatible Array Declarations)\n/* In a.c */\nextern int *a;   /* UB 15 */\n \nint f(unsigned int i, int x) {\n  int tmp = a[i];   /* UB 37: read access */\n  a[i] = x;         /* UB 37: write access */\n  return tmp;\n}\n \n/* In b.c */\nint a[] = { 1, 2, 3, 4 };   /* UB 15 */\n"}
{"id": "DCL40-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/nc2.c", "kind": "noncompliant", "text": "// DCL40-C: Noncompliant Code Example (Incompatible Function Declarations)\n/* In a.c */\nextern int f(int a);   /* UB 15 */\n \nint g(int a) {\n  return f(a);   /* UB 41 */\n}\n \n/* In b.c */\nlong f(long a) {   /* UB 15 */\n  return a * 2;\n}\n"}
{"id": "DCL40-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/nc3.c", "kind": "noncompliant", "text": "// DCL40-C: Noncompliant Code Example (Incompatible Variadic Function Declarations)\n/* In a.c */\nvoid buginf(const char *fmt, ...) {\n   /* ... */\n}\n  \n/* In b.c */\nvoid buginf();\n"}
{"id": "DCL40-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "DCL40-C", "file_path": "rules/dcl/40/nc4.c", "kind": "noncompliant", "text": "// DCL40-C: Noncompliant Code Example (Excessively Long Identifiers)\n/* In bashline.h */\n/* UB 15, UB 31 */\nextern char * bash_groupname_completion_function(const char *, int);\n \n/* In a.c */\n#include \"bashline.h\"\n \nvoid f(const char *s, int i) {\n  bash_groupname_completion_function(s, i);  /* UB 41 */\n}\n \n/* In b.c */\nint bash_groupname_completion_funct;  /* UB 15, UB 31 */\n"}
{"id": "ERR30-C_pdf_0", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "to set errno, and check errno only after the function returns a value indicating failure The value of is initialized to zero at program startup, but it is never subsequently set to errno zero by any C standard library function. The value of may be set to nonzero by a C stand- errno ard library function call whether or not there is an error, provided the use of is not docu- errno mented in the description of the function. It is meaningful for a program to inspect the contents of only after an error might have occurred. More precisely, is meaningful only after a errno errno library function that sets on error has returned an error code. errno According to Question 20.4 of C-FAQ [Summit 2005] In general, you should detect errors by checking return values, and use only to errno distinguish among the various causes of an error, such as File not found or Permis- sion denied. (Typically, you use or to print these discriminating error perror strerror messages.) Its only necessary to detect errors with when a function does not errno have a unique, unambiguous, out-of-band error return (that is, because all of its possible return values are valid; one example is sic ). In these cases (and in these atoi [ ] cases only; check the documentation to be sure whether a function allows this), you can detect errors by setting to 0, calling the function, and then testing ."}
{"id": "ERR30-C_pdf_1", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "(Setting errno errno to 0 first is important, as no library function ever does that for you.) errno Note that is not required to set the value of . atoi() errno Library functions fall into the following categories:  Those that set errno and return and out-of-band error indicator  Those that set errno and return and in-band error indicator  Those that do not promise to set errno  Those with differing standards documentation 13.1.1 Library Functions that Set and Return an Out-of-Band Error errno Indicator The C Standard specifies that the functions listed in the following table set and return an errno out-of-band error indicator. That is, their return value on error can never be returned by a success- ful call. A program may set and check for these library functions but is not required to do so. The errno program should not check the value of without first verifying that the function returned an errno SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 374 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure error indicator. For example, should not be checked after calling without first errno signal() ensuring that actually returned ."}
{"id": "ERR30-C_pdf_2", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "signal() SIG_ERR Functions That Set and Return an Out-of-Band Error Indicator errno Function Name Return Value errno Value Positive ftell() -1L , Nonzero Positive fgetpos() fsetpos() , mbrtowc() mbsrtowcs() (size_t)(-1) EILSEQ Positive signal() SIG_ERR , wcrtomb() wcsrtombs() (size_t)(-1) EILSEQ , mbrtoc16() mbrtoc32() (size_t)(-1) EILSEQ , c16rtomb() cr32rtomb() (size_t)(-1) EILSEQ 13.1.2 Library Functions that Set and Return an In-Band Error Indicator errno The C Standard specifies that the functions listed in the following table set and return an errno in-band error indicator. That is, the return value when an error occurs is also a valid return value for successful calls. For example, the function returns and sets to strtoul() ULONG_MAX errno if an error occurs. Because is a valid return value, must be used to ERANGE ULONG_MAX errno check whether an error actually occurred. A program that uses for error checking must set errno it to before calling one of these library functions and then inspect before a subsequent 0 errno library function call. The and functions return in multiple cases, only one of which results fgetwc() fputwc() WEOF in setting . The string conversion functions will return the maximum or minimum repre- errno sentable value and set to if the converted value cannot be represented by the data errno ERANGE type."}
{"id": "ERR30-C_pdf_3", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "However, if the conversion cannot happen because the input is invalid, the function will re- turn , and the output pointer parameter will be assigned the value of the input pointer parameter, 0 provided the output parameter is non-null. Functions that Set and Return an In-Band Error Indicator errno Function Name Return Value errno Value , fgetwc() fputwc() WEOF EILSEQ , or strtol() wcstol() LONG_MIN LONG_MAX ERANGE , or strtoll() wcstoll() LLONG_MIN LLONG_MAX ERANGE , strtoul() wcstoul() ULONG_MAX ERANGE , strtoull() wcstoull() ULLONG_MAX ERANGE , strtoumax()wcstoumax() UINTMAX_MAX ERANGE , or strtod() wcstod() 0 HUGE_VAL ERANGE , or strtof() wcstof() 0 HUGE_VALF ERANGE SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 375 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure Function Name Return Value errno Value , or strtold() wcstold() 0 HUGE_VALL ERANGE , , strtoimax()wcstoimax() INTMAX_MIN INTMAX_MAX ERANGE 13.1.3 Library Functions that Do Not Promise to Set errno The C Standard fails to document the behavior of for some functions."}
{"id": "ERR30-C_pdf_4", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "For example, the errno function normally returns a null pointer in the event of an error, but no guarantees setlocale() are made about setting . errno After calling one of these functions, a program should not rely solely on the value of to de- errno termine if an error occurred. The function might have altered , but this does not ensure that errno will properly indicate an error condition. errno 13.1.4 Library Functions with Differing Standards Documentation Some functions behave differently regarding in various standards. The function errno fopen() is one such example. When encounters an error, it returns a null pointer. The C Standard fopen() makes no mention of when describing . However, POSIX.1 declares that when errno fopen() encounters an error, it returns a null pointer and sets to a value indicating the er- fopen() errno ror [IEEE Std 1003.1-2013]. The implication is that a program conforming to C but not to POSIX (such as a Windows program) should not check after calling , but a POSIX pro- errno fopen() gram may check if returns a null pointer. errno fopen() 13.1.5 Library Functions and errno The following uses of are documented in the C Standard: errno  Functions defined in <complex.h> may set errno but are not required to.  For numeric conversion functions in the strtod , strtol , wcstod , and wcstol families, if the correct result is outside the range of representable values, an appropriate minimum or maximum value is returned and the value is stored in ."}
{"id": "ERR30-C_pdf_5", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "For floating-point con- ERANGE errno version functions in the and families, if an underflow occurs, whether strtod wcstod acquires the value is implementation-defined. If the conversion fails, is re- errno ERANGE 0 turned and is not set. errno  The numeric conversion function atof() and those in the atoi family need not affect the value of . errno  For mathematical functions in <math.h> , if the integer expression math_errhandling & is nonzero, on a domain error, acquires the value ; on an overflow MATH_ERRNO errno EDOM with default rounding or if the mathematical result is an exact infinity from finite arguments, acquires the value ; and on an underflow, whether acquires the value errno ERANGE errno is implementation-defined. ERANGE  If a request made by calling signal() cannot be honored, a value of SIG_ERR is returned and a positive value is stored in . errno SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 376 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR30-C. Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure  The byte I/O functions, wide-character I/O functions, and multibyte conversion functions store the value of the macro in if and only if an encoding error occurs."}
{"id": "ERR30-C_pdf_6", "source": "CERT_PDF", "cert_rule": "ERR30-C", "title": "Set errno to zero before calling a library function known", "kind": "description", "text": "EILSEQ errno  On failure, fgetpos() and fsetpos() return nonzero and store an implementation-defined positive value in . errno  On failure, ftell() returns -1L and stores an implementation-defined positive value in . errno  The perror() function maps the error number in errno to a message and writes it to . stderr The POSIX.1 standard defines the use of by many more functions (including the C stand- errno ard library function). POSIX also has a small set of functions that are exceptions to the rule. These functions have no return value reserved to indicate an error, but they still set on error. To errno detect an error, an application must set to before calling the function and check whether errno 0 it is nonzero after the call. Affected functions include , , , strcoll() strxfrm() strerror() , , and .The C Standard allows these functions to set to a wcscoll() wcsxfrm() fwide() errno nonzero value on success. Consequently, this type of error checking should be performed only on POSIX systems. 13.1.6"}
{"id": "ERR30-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "ERR30-C", "file_path": "rules/err/30/c0.c", "kind": "compliant", "text": "// ERR30-C: Compliant Solution (strtoul())\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n  \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n  \n  errno = 0;\n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX\n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}\n"}
{"id": "ERR30-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "ERR30-C", "file_path": "rules/err/30/c1.c", "kind": "compliant", "text": "// ERR30-C: Compliant Solution (fopen(), C)\n#include <stdio.h>\n  \nvoid func(const char *filename) {\n  FILE *fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /* An error occurred in fopen() */\n  }\n}\n"}
{"id": "ERR30-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "ERR30-C", "file_path": "rules/err/30/c2.c", "kind": "compliant", "text": "// ERR30-C: Compliant Solution (fopen(), POSIX)\n#include <errno.h>\n#include <stdio.h>\n  \nvoid func(const char *filename) {\n  FILE *fileptr;\n \n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (fileptr == NULL)  {\n    /*\n     * An error occurred in fopen(); now it's valid\n     * to examine errno.\n     */\n    perror(filename);\n  }\n}\n"}
{"id": "ERR30-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "ERR30-C", "file_path": "rules/err/30/nc0.c", "kind": "noncompliant", "text": "// ERR30-C: Noncompliant Code Example (strtoul())\n#include <errno.h>\n#include <limits.h>\n#include <stdlib.h>\n  \nvoid func(const char *c_str) {\n  unsigned long number;\n  char *endptr;\n   \n  number = strtoul(c_str, &endptr, 0);\n  if (endptr == c_str || (number == ULONG_MAX\n                         && errno == ERANGE)) {\n    /* Handle error */\n  } else {\n    /* Computation succeeded */\n  }\n}\n"}
{"id": "ERR30-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "ERR30-C", "file_path": "rules/err/30/nc1.c", "kind": "noncompliant", "text": "// ERR30-C: Noncompliant Code Example (fopen())\n#include <errno.h>\n#include <stdio.h>\n  \nvoid func(const char *filename) {\n  FILE *fileptr;\n \n  errno = 0;\n  fileptr = fopen(filename, \"rb\");\n  if (errno != 0) {\n    /* Handle error */\n  }\n}\n"}
{"id": "ERR33-C_pdf_0", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "The majority of the standard library functions, including I/O functions and memory allocation functions, return either a valid value or a value of the correct return type that indicates an error (for example, 1 or a null pointer). Assuming that all calls to such functions will succeed and fail- ing to check the return value for an indication of an error is a dangerous practice that may lead to unexpected or undefined behavior when an error occurs. It is essential that programs detect and appropriately handle all errors in accordance with an error-handling policy, as discussed in ERR00-C. Adopt and implement a consistent and comprehensive error-handling policy. The successful completion or failure of each of the standard library functions listed in the follow- ing table shall be determined either by comparing the functions return value with the value listed in the column labeled Error Return or by calling one of the library functions mentioned in the footnotes."}
{"id": "ERR33-C_pdf_1", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Standard Library Functions Function Successful Return Error Return Pointer to space aligned_alloc() NULL Nonzero asctime_s() 0 Nonzero at_quick_exit() 0 Nonzero atexit() 0 Pointer to matching element bsearch() NULL Pointer to matching element bsearch_s() NULL Converted wide character btowc() WEOF Number of bytes c16rtomb() (size_t)(-1) Number of bytes c32rtomb() (size_t)(-1) Pointer to space calloc() NULL Processor time clock() (clock_t)(-1) cnd_broadcast() thrd_success thrd_error or cnd_init() thrd_success thrd_nomem thrd_error cnd_signal() thrd_success thrd_error or cnd_timedwait() thrd_success thrd_timedout thrd_error cnd_wait() thrd_success thrd_error Nonzero ctime_s() 0 (negative) fclose() 0 EOF (negative) fflush() 0 EOF SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 386 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR33-C."}
{"id": "ERR33-C_pdf_2", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Detect and handle standard library errors Function Successful Return Error Return fgetc() Character read EOF6 Nonzero, fgetpos() 0 errno > 0 Pointer to string fgets() NULL fgetwc() Wide character read WEOF6 Pointer to stream fopen() NULL Nonzero fopen_s() 0 Number of characters Negative fprintf() (nonnegative) Number of characters Negative fprintf_s() (nonnegative) fputc() Character written EOF7 Nonnegative (negative) fputs() EOF Wide character written fputwc() WEOF Nonnegative (negative) fputws() EOF Elements read Elements read fread() Pointer to stream freopen() NULL Nonzero freopen_s() 0 Number of conversions (negative) fscanf() EOF (nonnegative) Number of conversions (negative) fscanf_s() EOF (nonnegative) Nonzero fseek() 0 Nonzero, fsetpos() 0 errno > 0 File position , ftell() 1L errno > 0 Number of wide characters Negative fwprintf() (nonnegative) Number of wide characters Negative fwprintf_s() (nonnegative) Elements written Elements written fwrite() Number of conversions (negative) fwscanf() EOF (nonnegative) Number of conversions (negative) fwscanf_s() EOF (nonnegative) getc() Character read EOF6 ______________________ 6 By calling ferror() and feof() 7 By calling ferror() SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 387 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR33-C."}
{"id": "ERR33-C_pdf_3", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Detect and handle standard library errors Function Successful Return Error Return getchar() Character read EOF6 Pointer to string getenv() NULL Pointer to string getenv_s() NULL Pointer to string gets_s() NULL Wide character read getwc() WEOF Wide character read getwchar() WEOF Pointer to broken-down time gmtime() NULL Pointer to broken-down time gmtime_s() NULL Pointer to broken-down time localtime() NULL Pointer to broken-down time localtime_s() NULL Pointer to space malloc() NULL Number of bytes mblen(), s != NULL 1 Number of bytes or status mbrlen(), s != NULL (size_t)(-1) Number of bytes or status , mbrtoc16() (size_t)(-1) errno == EILSEQ Number of bytes or status , mbrtoc32() (size_t)(-1) errno == EILSEQ Number of bytes or status , mbrtowc(), s != NULL (size_t)(-1) errno == EILSEQ Number of non-null elements , mbsrtowcs() (size_t)(-1) errno == EILSEQ Nonzero mbsrtowcs_s() 0 Number of non-null elements mbstowcs() (size_t)(-1) Nonzero mbstowcs_s() 0 Number of bytes mbtowc(), s != NULL 1 Pointer to located character memchr() NULL Calendar time mktime() (time_t)(-1) mtx_init() thrd_success thrd_error mtx_lock() thrd_success thrd_error or mtx_timedlock() thrd_success thrd_timedout thrd_error or mtx_trylock() thrd_success thrd_busy thrd_error mtx_unlock() thrd_success thrd_error Number of characters Negative printf_s() (nonnegative) Character written 7 putc() EOF SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 388 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution."}
{"id": "ERR33-C_pdf_4", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Error Handling (ERR) - ERR33-C."}
{"id": "ERR33-C_pdf_5", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Detect and handle standard library errors Function Successful Return Error Return Wide character written putwc() WEOF Nonzero raise() 0 Pointer to space realloc() NULL Nonzero remove() 0 Nonzero rename() 0 Pointer to string setlocale() NULL Nonzero setvbuf() 0 Number of conversions (negative) scanf() EOF (nonnegative) Number of conversions (negative) scanf_s() EOF (nonnegative) Pointer to previous function , signal() SIG_ERR errno > 0 Number of characters that Negative snprintf() would be written (nonnegative) Number of characters that Negative snprintf_s() would be written (nonnegative) Number of non-null characters Negative sprintf() written Number of non-null characters Negative sprintf_s() written Number of conversions (negative) sscanf() EOF (nonnegative) Number of conversions (negative) sscanf_s() EOF (nonnegative) Pointer to located character strchr() NULL Nonzero strerror_s() 0 Number of non-null characters strftime() 0 Pointer to located character strpbrk() NULL Pointer to located character strrchr() NULL Pointer to located string strstr() NULL Converted value , strtod() 0 errno == ERANGE Converted value , strtof() 0 errno == ERANGE Converted value or , strtoimax() INTMAX_MAX INTMAX_MIN errno == ERANGE Pointer to first character of a strtok() NULL token SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 389 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution."}
{"id": "ERR33-C_pdf_6", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Error Handling (ERR) - ERR33-C. Detect and handle standard library errors Function Successful Return Error Return Pointer to first character of a strtok_s() NULL token Converted value or , strtol() LONG_MAX LONG_MIN errno == ERANGE Converted value strtold() 0, errno == ERANGE Converted value or , strtoll() LLONG_MAX LLONG_MIN errno == ERANGE Converted value , strtoumax() UINTMAX_MAX errno == ERANGE Converted value , strtoul() ULONG_MAX errno == ERANGE Converted value , strtoull() ULLONG_MAX errno == ERANGE Length of transformed string strxfrm() >= n Number of non-null wide char- Negative swprintf() acters Number of non-null wide char- Negative swprintf_s() acters Number of conversions (negative) swscanf() EOF (nonnegative) Number of conversions (negative) swscanf_s() EOF (nonnegative) or thrd_create() thrd_success thrd_nomem thrd_error thrd_detach() thrd_success thrd_error thrd_join() thrd_success thrd_error Negative thrd_sleep() 0 Calendar time time() (time_t)(-1) Base timespec_get() 0 Pointer to stream tmpfile() NULL Nonzero tmpfile_s() 0 Non-null pointer tmpnam() NULL Nonzero tmpnam_s() 0 tss_create() thrd_success thrd_error Value of thread-specific stor- tss_get() 0 age tss_set() thrd_success thrd_error SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 390 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR33-C."}
{"id": "ERR33-C_pdf_7", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Detect and handle standard library errors Function Successful Return Error Return Character pushed back 8 ungetc() EOF Character pushed back ungetwc() WEOF Number of characters Negative vfprintf() (nonnegative) Number of characters Negative vfprintf_s() (nonnegative) Number of conversions (negative) vfscanf() EOF (nonnegative) Number of conversions (negative) vfscanf_s() EOF (nonnegative) Number of wide characters Negative vfwprintf() (nonnegative) Number of wide characters Negative vfwprintf_s() (nonnegative) Number of conversions (negative) vfwscanf() EOF (nonnegative) Number of conversions (negative) vfwscanf_s() EOF (nonnegative) Number of characters Negative vprintf_s() (nonnegative) Number of conversions (negative) vscanf() EOF (nonnegative) Number of conversions (negative) vscanf_s() EOF (nonnegative) Number of characters that Negative vsnprintf() would be written (nonnegative) Number of characters that Negative vsnprintf_s() would be written (nonnegative) Number of non-null characters Negative vsprintf() (nonnegative) Number of non-null characters Negative vsprintf_s() (nonnegative) ______________________ 8 The ungetc() function does not set the error indicator even when it fails, so it is not possible to check for errors reliably unless it is known that the argument is not equal to EOF."}
{"id": "ERR33-C_pdf_8", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "The C Standard [ISO/IEC 9899:2011] states that one character of pushback is guaranteed, so this should not be an issue if, at most, one character is ever pushed back before reading again. (See FIO13-C. Never push back anything other than one read char- acter.) SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 391 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR33-C."}
{"id": "ERR33-C_pdf_9", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Detect and handle standard library errors Function Successful Return Error Return Number of conversions (negative) vsscanf() EOF (nonnegative) Number of conversions (negative) vsscanf_s() EOF (nonnegative) Number of non-null wide char- Negative vswprintf() acters Number of non-null wide char- Negative vswprintf_s() acters Number of conversions (negative) vswscanf() EOF (nonnegative) Number of conversions (negative) vswscanf_s() EOF (nonnegative) Number of wide characters Negative vwprintf_s() (nonnegative) Number of conversions (negative) vwscanf() EOF (nonnegative) Number of conversions (negative) vwscanf_s() EOF (nonnegative) Number of bytes stored wcrtomb() (size_t)(-1) Pointer to located wide charac- wcschr() NULL ter Number of non-null wide char- wcsftime() 0 acters Pointer to located wide charac- wcspbrk() NULL ter Pointer to located wide charac- wcsrchr() NULL ter Number of non-null bytes , wcsrtombs() (size_t)(-1) errno == EILSEQ Nonzero wcsrtombs_s() 0 Pointer to located wide string wcsstr() NULL Converted value , wcstod() 0 errno == ERANGE Converted value , wcstof() 0 errno == ERANGE Converted value or , wcstoimax() INTMAX_MAX INTMAX_MIN errno == ERANGE Pointer to first wide character wcstok() NULL of a token SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 392 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution."}
{"id": "ERR33-C_pdf_10", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Error Handling (ERR) - ERR33-C. Detect and handle standard library errors Function Successful Return Error Return Pointer to first wide character wcstok_s() NULL of a token Converted value or , wcstol() LONG_MAX LONG_MIN errno == ERANGE Converted value , wcstold() 0 errno == ERANGE Converted value or , wcstoll() LLONG_MAX LLONG_MIN errno == ERANGE Number of non-null bytes wcstombs() (size_t)(-1) Nonzero wcstombs_s() 0 Converted value , wcstoumax() UINTMAX_MAX errno == ERANGE Converted value , wcstoul() ULONG_MAX errno == ERANGE Converted value , wcstoull() ULLONG_MAX errno == ERANGE Length of transformed wide wcsxfrm() >= n string Converted character wctob() EOF Number of bytes stored wctomb(), s != NULL 1 Number of bytes stored wctomb_s(), s != NULL 1 Valid argument to wctrans() 0 towctrans Valid argument to wctype() iswctype 0 Pointer to located wide charac- wmemchr() NULL ter Number of wide characters Negative wprintf_s() (nonnegative) Number of conversions (negative) wscanf() EOF (nonnegative) Number of conversions (negative) wscanf_s() EOF (nonnegative) Note: According to FIO35-C."}
{"id": "ERR33-C_pdf_11", "source": "CERT_PDF", "cert_rule": "ERR33-C", "title": "Detect and handle standard library errors", "kind": "description", "text": "Use feof() and ferror() to detect end-of-file and file errors when sizeof(int) == sizeof(char), callers should verify end-of-file and file errors for the functions in this table as follows: 1 By calling and ferror() feof() 2 By calling ferror() SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 393 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Error Handling (ERR) - ERR33-C. Detect and handle standard library errors 13.3.1"}
{"id": "ERR33-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c0.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (setlocale())\n#include <locale.h>\n#include <stdlib.h>\n  \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  const char *save = setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  if (NULL == save) {\n    return -1;\n  }\n \n  *size = mbstowcs(wcs, utf8, n);\n  if (NULL == setlocale(LC_CTYPE, save)) {\n    return -1;\n  }\n  return 0;\n}\n"}
{"id": "ERR33-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c1.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (calloc())\n#include <stdlib.h>\n#include <string.h>\n \nenum { SIG_DESC_SIZE = 32 };\n \ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n  \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                           sizeof(signal_info));\n  if (start == NULL) {\n    /* Handle allocation error */\n  } else if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n \n  signal_info *point = start + temp_num - 1;\n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}\n"}
{"id": "ERR33-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c2.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (realloc())\n#include <stdlib.h>\n  \nvoid *p;\nvoid func(size_t new_size) {\n  void *q;\n \n  if (new_size == 0) {\n    /* Handle error */\n  }\n  \n  q = realloc(p, new_size);\n  if (q == NULL) {\n   /* Handle error */\n  } else {\n    p = q;\n  }\n}\n"}
{"id": "ERR33-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c3.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (fseek())\n#include <stdio.h>\n  \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  if (fseek(file, offset, SEEK_SET) != 0) {\n    /* Indicate error to caller */\n    return 0;\n  }\n  return fread(buf, 1, nbytes, file);\n}\n"}
{"id": "ERR33-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c4.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (snprintf())\n#include <stdio.h>\n#include <string.h>\n  \nextern void log_message(const char *);\n \nvoid f(int i, int width, int prec) {\n  char buf[40];\n  int n;\n  n = snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  if (n < 0 || n >= sizeof(buf)) {\n    /* Handle snprintf() error */\n    strcpy(buf, \"unknown error\");\n  }\n  log_message(buf);\n}\n"}
{"id": "ERR33-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/c5.c", "kind": "compliant", "text": "// ERR33-C: Compliant Solution (snprintf(null))\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  \nextern void log_message(const char *);\n  \nvoid f(int i, int width, int prec) {\n  char buffer[20];\n  char *buf = buffer;\n  int n  = sizeof(buffer);\n  const char fmt[] = \"i = %*.*i\";\n \n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n \n  if (n < sizeof(buffer)) {\n    goto write_log;\n  }\n \n  buf = (char *)malloc(n + 1);\n  if (NULL == buf) {\n    /* Handle malloc() error */\n    strcpy(buffer, \"unknown error\");\n    goto write_log;\n  }\n \n  n = snprintf(buf, n, fmt, width, prec, i);\n  if (n < 0) {\n    /* Handle snprintf() error */\n    strcpy(buffer, \"unknown error\");\n  }\n \nwrite_log:\n  log_message(buf);\n \n  if (buf != buffer) {\n    free(buf);\n  }\n}\n"}
{"id": "ERR33-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/nc0.c", "kind": "noncompliant", "text": "// ERR33-C: Noncompliant Code Example (setlocale())\n#include <locale.h>\n#include <stdlib.h>\n  \nint utf8_to_wcs(wchar_t *wcs, size_t n, const char *utf8,\n                size_t *size) {\n  if (NULL == size) {\n    return -1;\n  }\n  setlocale(LC_CTYPE, \"en_US.UTF-8\");\n  *size = mbstowcs(wcs, utf8, n);\n  return 0;\n}\n"}
{"id": "ERR33-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/nc1.c", "kind": "noncompliant", "text": "// ERR33-C: Noncompliant Code Example (calloc())\n#include <stdlib.h>\n#include <string.h>\n  \nenum { SIG_DESC_SIZE = 32 };\n \ntypedef struct {\n  char sig_desc[SIG_DESC_SIZE];\n} signal_info;\n  \nvoid func(size_t num_of_records, size_t temp_num,\n          const char *tmp2, size_t tmp2_size_bytes) {\n  signal_info *start = (signal_info *)calloc(num_of_records,\n                                          sizeof(signal_info));\n \n  if (tmp2 == NULL) {\n    /* Handle error */\n  } else if (temp_num > num_of_records) {\n    /* Handle error */\n  } else if (tmp2_size_bytes < SIG_DESC_SIZE) {\n    /* Handle error */\n  }\n \n  signal_info *point = start + temp_num - 1;\n  memcpy(point->sig_desc, tmp2, SIG_DESC_SIZE);\n  point->sig_desc[SIG_DESC_SIZE - 1] = '\\0';\n  /* ... */\n  free(start);\n}\n"}
{"id": "ERR33-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/nc2.c", "kind": "noncompliant", "text": "// ERR33-C: Noncompliant Code Example (realloc())\n#include <stdlib.h>\n  \nvoid *p;\nvoid func(size_t new_size) {\n  if (new_size == 0) {\n    /* Handle error */\n  }\n  p = realloc(p, new_size);\n  if (p == NULL) {\n   /* Handle error */\n  }\n}\n"}
{"id": "ERR33-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/nc3.c", "kind": "noncompliant", "text": "// ERR33-C: Noncompliant Code Example (fseek())\n#include <stdio.h>\n  \nsize_t read_at(FILE *file, long offset,\n               void *buf, size_t nbytes) {\n  fseek(file, offset, SEEK_SET);\n  return fread(buf, 1, nbytes, file);\n}\n"}
{"id": "ERR33-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "ERR33-C", "file_path": "rules/err/33/nc4.c", "kind": "noncompliant", "text": "// ERR33-C: Noncompliant Code Example (snprintf())\n#include <stdio.h>\n  \nextern void log_message(const char *);\n \nvoid f(int i, int width, int prec) {\n  char buf[40];\n  snprintf(buf, sizeof(buf), \"i = %*.*i\", width, prec, i);\n  log_message(buf);\n  /* ... */\n}\n"}
{"id": "EXP33-C_pdf_0", "source": "CERT_PDF", "cert_rule": "EXP33-C", "title": "Do not read uninitialized memory", "kind": "description", "text": "Local, automatic variables assume unexpected values if they are read before they are initialized. The C Standard, 6.7.9, paragraph 10, specifies [ISO/IEC 9899:2011] If an object that has automatic storage duration is not initialized explicitly, its value is in- determinate. See undefined behavior 11. When local, automatic variables are stored on the program stack, for example, their values default to whichever values are currently stored in stack memory. Additionally, some dynamic memory allocation functions do not initialize the contents of the memory they allocate. Function Initialization Does not perform initialization aligned_alloc() Zero-initializes allocated memory calloc() Does not perform initialization malloc() Copies contents from original pointer; may not initial- realloc() ize all memory Uninitialized automatic variables or dynamically allocated memory has indeterminate values, which, for objects of some types, can be a trap representation. Reading such trap representations is undefined behavior (see undefined behavior 10 and undefined behavior 12); it can cause a pro- gram to behave in an unexpected manner and provide an avenue for attack. In many cases, com- pilers issue a warning diagnostic message when reading uninitialized variables. (See MSC00-C. Compile cleanly at high warning levels for more information.) 4.3.1"}
{"id": "EXP33-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c0.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (Return-by-Reference)\nvoid set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n \n  /* Account for number being 0 */\n  if (number >= 0) {\n    *sign_flag = 1;\n  } else {\n    *sign_flag = -1;\n  }\n}\n \nint is_negative(int number) {\n  int sign = 0; /* Initialize for defense-in-depth */\n  set_flag(number, &sign);\n  return sign < 0;\n}\n"}
{"id": "EXP33-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c1.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (Uninitialized Local)\n#include <stdio.h>\nenum { BUFFERSIZE = 24 };\nvoid report_error(const char *msg) {\n  char buffer[BUFFERSIZE];\n \n  if (0 < snprintf(buffer, BUFFERSIZE, \"Error: %s\", msg))\n    printf(\"%s\\n\", buffer);\n  else\n    puts(\"Unknown error\");\n}\n"}
{"id": "EXP33-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c2.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (Uninitialized Local)\n#include <stdio.h>\n  \nvoid report_error(const char *msg) {\n  printf(\"Error: %s\\n\", msg);\n}\n"}
{"id": "EXP33-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c3.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (mbstate_t)\n#include <string.h>\n#include <wchar.h>\n  \nvoid func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n \n  memset(&state, 0, sizeof(state));\n  len = mbrlen(mbs, strlen(mbs), &state);\n}\n"}
{"id": "EXP33-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c4.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (POSIX, Entropy)\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n \nvoid func(void) {    \n  double cpu_time;\n  struct timeval tv;\n \n  cpu_time = ((double) clock()) / CLOCKS_PER_SEC;\n  gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ cpu_time);\n}\n"}
{"id": "EXP33-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/c5.c", "kind": "compliant", "text": "// EXP33-C: Compliant Solution (realloc())\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n \nenum { OLD_SIZE = 10, NEW_SIZE = 20 };\n  \nint *resize_array(int *array, size_t old_count, size_t new_count) {\n  if (0 == new_count) {\n    return 0;\n  }\n  \n  int *ret = (int *)realloc(array, new_count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n  \n  if (new_count > old_count) {\n    memset(ret + old_count, 0, (new_count - old_count) * sizeof(int));\n  }\n  \n  return ret;\n}\n  \nvoid func(void) {\n  \n  int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n  \n  for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n  \n  array = resize_array(array, OLD_SIZE, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n  \n  for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}\n"}
{"id": "EXP33-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc0.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (Return-by-Reference)\nvoid set_flag(int number, int *sign_flag) {\n  if (NULL == sign_flag) {\n    return;\n  }\n \n  if (number > 0) {\n    *sign_flag = 1;\n  } else if (number < 0) {\n    *sign_flag = -1;\n  }\n}\n \nint is_negative(int number) {\n  int sign;\n  set_flag(number, &sign);\n  return sign < 0;\n}\n"}
{"id": "EXP33-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc1.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (Uninitialized Local)\n#include <stdio.h>\n \n/* Get username and password from user, return -1 on error */\nextern int do_auth(void);\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log;\n  char buffer[BUFFERSIZE];\n \n  sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n \nint main(void) {\n  if (do_auth() == -1) {\n    report_error(\"Unable to login\");\n  }\n  return 0;\n}\n"}
{"id": "EXP33-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc2.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (Uninitialized Local)\n#include <stdio.h>\nenum { BUFFERSIZE = 24 }; \nvoid report_error(const char *msg) {\n  const char *error_log = msg;\n  char buffer[BUFFERSIZE];\n \n  sprintf(buffer, \"Error: %s\", error_log);\n  printf(\"%s\\n\", buffer);\n}\n"}
{"id": "EXP33-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc3.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (mbstate_t)\n#include <string.h>\n#include <wchar.h>\n  \nvoid func(const char *mbs) {\n  size_t len;\n  mbstate_t state;\n \n  len = mbrlen(mbs, strlen(mbs), &state);\n}\n"}
{"id": "EXP33-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc4.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (POSIX, Entropy)\n#include <time.h>\n#include <unistd.h>\n#include <stdlib.h>\n#include <sys/time.h>\n   \nvoid func(void) {\n  struct timeval tv;\n  unsigned long junk;\n \n  gettimeofday(&tv, NULL);\n  srandom((getpid() << 16) ^ tv.tv_sec ^ tv.tv_usec ^ junk);\n}\n"}
{"id": "EXP33-C_samples_nc5.c", "source": "CERT_SAMPLES", "cert_rule": "EXP33-C", "file_path": "rules/exp/33/nc5.c", "kind": "noncompliant", "text": "// EXP33-C: Noncompliant Code Example (realloc())\n#include <stdlib.h>\n#include <stdio.h>\nenum { OLD_SIZE = 10, NEW_SIZE = 20 };\n  \nint *resize_array(int *array, size_t count) {\n  if (0 == count) {\n    return 0;\n  }\n  \n  int *ret = (int *)realloc(array, count * sizeof(int));\n  if (!ret) {\n    free(array);\n    return 0;\n  }\n  \n  return ret;\n}\n  \nvoid func(void) {\n  \n  int *array = (int *)malloc(OLD_SIZE * sizeof(int));\n  if (0 == array) {\n    /* Handle error */\n  }\n  \n  for (size_t i = 0; i < OLD_SIZE; ++i) {\n    array[i] = i;\n  }\n  \n  array = resize_array(array, NEW_SIZE);\n  if (0 == array) {\n    /* Handle error */\n  }\n  \n  for (size_t i = 0; i < NEW_SIZE; ++i) {\n    printf(\"%d \", array[i]);\n  }\n}\n"}
{"id": "EXP34-C_pdf_0", "source": "CERT_PDF", "cert_rule": "EXP34-C", "title": "Do not dereference null pointers", "kind": "description", "text": "Dereferencing a null pointer is undefined behavior. On many platforms, dereferencing a null pointer results in abnormal program termination, but this is not required by the standard. See Clever Attack Exploits Fully-Patched Linux Kernel [Goodin 2009] for an example of a code execution exploit that resulted from a null pointer deref- erence. 4.4.1"}
{"id": "EXP34-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/c0.c", "kind": "compliant", "text": "// EXP34-C: Compliant Solution\n#include <png.h> /* From libpng */\n#include <string.h>\n \n void func(png_structp png_ptr, size_t length, const void *user_data) {\n  png_charp chunkdata;\n  if (length == SIZE_MAX) {\n    /* Handle error */\n  }\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  if (NULL == chunkdata) {\n    /* Handle error */\n  }\n  if (NULL == user_data) {\n    /* Handle error */\n  }\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n \n }\n"}
{"id": "EXP34-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/c1.c", "kind": "compliant", "text": "// EXP34-C: Compliant Solution\n#include <string.h>\n#include <stdlib.h>\n  \nvoid f(const char *input_str) {\n  size_t size;\n  char *c_str;\n  \n  if (NULL == input_str) {\n    /* Handle error */\n  }\n   \n  size = strlen(input_str) + 1;\n  c_str = (char *)malloc(size);\n  if (NULL == c_str) {\n    /* Handle error */\n  }\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}\n"}
{"id": "EXP34-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/c2.c", "kind": "compliant", "text": "// EXP34-C: Compliant Solution\nstatic unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  assert(file);\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk;\n  unsigned int mask = 0;\n \n  if (!tun)\n    return POLLERR;\n  assert(tun->dev);\n  sk = tun->sk;\n  assert(sk);\n  assert(sk->socket);\n  /* The remaining code is omitted because it is unchanged... */\n}\n"}
{"id": "EXP34-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/nc0.c", "kind": "noncompliant", "text": "// EXP34-C: Noncompliant Code Example\n#include <png.h> /* From libpng */\n#include <string.h>\n  \nvoid func(png_structp png_ptr, int length, const void *user_data) {\n  png_charp chunkdata;\n  chunkdata = (png_charp)png_malloc(png_ptr, length + 1);\n  /* ... */\n  memcpy(chunkdata, user_data, length);\n  /* ... */\n }\n"}
{"id": "EXP34-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/nc1.c", "kind": "noncompliant", "text": "// EXP34-C: Noncompliant Code Example\n#include <string.h>\n#include <stdlib.h>\n  \nvoid f(const char *input_str) {\n  size_t size = strlen(input_str) + 1;\n  char *c_str = (char *)malloc(size);\n  memcpy(c_str, input_str, size);\n  /* ... */\n  free(c_str);\n  c_str = NULL;\n  /* ... */\n}\n"}
{"id": "EXP34-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP34-C", "file_path": "rules/exp/34/nc2.c", "kind": "noncompliant", "text": "// EXP34-C: Noncompliant Code Example\nstatic unsigned int tun_chr_poll(struct file *file, poll_table *wait)  {\n  struct tun_file *tfile = file->private_data;\n  struct tun_struct *tun = __tun_get(tfile);\n  struct sock *sk = tun->sk;\n  unsigned int mask = 0;\n \n  if (!tun)\n    return POLLERR;\n \n  DBG(KERN_INFO \"%s: tun_chr_poll\\n\", tun->dev->name);\n \n  poll_wait(file, &tun->socket.wait, wait);\n \n  if (!skb_queue_empty(&tun->readq))\n    mask |= POLLIN | POLLRDNORM;\n \n  if (sock_writeable(sk) ||\n     (!test_and_set_bit(SOCK_ASYNC_NOSPACE, &sk->sk_socket->flags) &&\n     sock_writeable(sk)))\n    mask |= POLLOUT | POLLWRNORM;\n \n  if (tun->dev->reg_state != NETREG_REGISTERED)\n    mask = POLLERR;\n \n  tun_put(tun);\n  return mask;\n}\n"}
{"id": "EXP36-C_pdf_0", "source": "CERT_PDF", "cert_rule": "EXP36-C", "title": "Do not cast pointers into more strictly aligned pointer", "kind": "description", "text": "types Do not convert a pointer value to a pointer type that is more strictly aligned than the referenced type. Different alignments are possible for different types of objects. If the type-checking system is overridden by an explicit cast or the pointer is converted to a void pointer ( ) and then to void * a different type, the alignment of an object may be changed. The C Standard, 6.3.2.3, paragraph 7 [ISO/IEC 9899:2011], states A pointer to an object or incomplete type may be converted to a pointer to a different ob- ject or incomplete type. If the resulting pointer is not correctly aligned for the referenced type, the behavior is undefined. See undefined behavior 25. If the misaligned pointer is dereferenced, the program may terminate abnormally. On some archi- tectures, the cast alone may cause a loss of information even if the value is not dereferenced if the types involved have differing alignment requirements. 4.6.1"}
{"id": "EXP36-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/c0.c", "kind": "compliant", "text": "// EXP36-C: Compliant Solution (Intermediate Object)\n#include <assert.h>\n  \nvoid func(void) {\n  char c = 'x';\n  int i = c;\n  int *ip = &i;\n \n  assert(ip == &i);\n}\n"}
{"id": "EXP36-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/c1.c", "kind": "compliant", "text": "// EXP36-C: Compliant Solution\nint *loop_function(int *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n  \nvoid func(int *loop_ptr) {\n  int *int_ptr = loop_function(loop_ptr);\n \n  /* ... */\n}\n"}
{"id": "EXP36-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/c2.c", "kind": "compliant", "text": "// EXP36-C: Compliant Solution\n#include <string.h>\n  \nstruct foo_header {\n  int len;\n  /* ... */\n};\n   \nvoid func(char *data, size_t offset) {\n  struct foo_header header;\n  memcpy(&header, data + offset, sizeof(header));\n \n  /* ... */\n}\n"}
{"id": "EXP36-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/nc0.c", "kind": "noncompliant", "text": "// EXP36-C: Noncompliant Code Example\n#include <assert.h>\n  \nvoid func(void) {\n  char c = 'x';\n  int *ip = (int *)&c; /* This can lose information */\n  char *cp = (char *)ip;\n \n  /* Will fail on some conforming implementations */\n  assert(cp == &c);\n}\n"}
{"id": "EXP36-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/nc1.c", "kind": "noncompliant", "text": "// EXP36-C: Noncompliant Code Example\nint *loop_function(void *v_pointer) {\n  /* ... */\n  return v_pointer;\n}\n  \nvoid func(char *char_ptr) {\n  int *int_ptr = loop_function(char_ptr);\n \n  /* ... */\n}\n"}
{"id": "EXP36-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP36-C", "file_path": "rules/exp/36/nc2.c", "kind": "noncompliant", "text": "// EXP36-C: Noncompliant Code Example\n#include <string.h>\n  \nstruct foo_header {\n  int len;\n  /* ... */\n};\n  \nvoid func(char *data, size_t offset) {\n  struct foo_header *tmp;\n  struct foo_header header;\n \n  tmp = (struct foo_header *)(data + offset);\n  memcpy(&header, tmp, sizeof(header));\n \n  /* ... */\n}\n"}
{"id": "EXP37-C_pdf_0", "source": "CERT_PDF", "cert_rule": "EXP37-C", "title": "Call functions with the correct number and type of", "kind": "description", "text": "arguments Do not call a function with the wrong number or type of arguments. The C Standard identifies five distinct situations in which undefined behavior (UB) may arise as a result of invoking a function using a declaration that is incompatible with its definition or by sup- plying incorrect types or numbers of arguments: UB Description 26 A pointer is used to call a function whose type is not compatible with the referenced type (6.3.2.3). 38 For a call to a function without a function prototype in scope, the number of arguments does not equal the number of parameters (6.5.2.2). 39 For a call to a function without a function prototype in scope where the function is defined with a function prototype, either the prototype ends with an ellipsis or the types of the argu- ments after promotion are not compatible with the types of the parameters (6.5.2.2). 40 For a call to a function without a function prototype in scope where the function is not de- fined with a function prototype, the types of the arguments after promotion are not compati- ble with those of the parameters after promotion (with certain exceptions) (6.5.2.2). 41 A function is defined with a type that is not compatible with the type (of the expression) pointed to by the expression that denotes the called function (6.5.2.2). Functions that are appropriately declared (as in DCL40-C."}
{"id": "EXP37-C_pdf_1", "source": "CERT_PDF", "cert_rule": "EXP37-C", "title": "Call functions with the correct number and type of", "kind": "description", "text": "Do not create incompatible declara- tions of the same function or object) will typically generate a compiler diagnostic message if they are supplied with the wrong number or types of arguments. However, there are cases in which supplying the incorrect arguments to a function will, at best, generate compiler warnings. Alt- hough such warnings should be resolved, they do not prevent program compilation. (See MSC00- C. Compile cleanly at high warning levels.) 4.7.1"}
{"id": "EXP37-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/c0.c", "kind": "compliant", "text": "// EXP37-C: Compliant Solution (Complex Number)\n#include <tgmath.h>\n  \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log(c)/log(2);\n}\n"}
{"id": "EXP37-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/c1.c", "kind": "compliant", "text": "// EXP37-C: Compliant Solution (Real Number)\n#include <tgmath.h>\n  \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(creal(c));\n}\n"}
{"id": "EXP37-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/c2.c", "kind": "compliant", "text": "// EXP37-C: Compliant Solution\n#include <stdio.h>\n#include <string.h>\n \nchar *(*fp)(const char *, int);\n \nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp(\"Hello\",'e');\n  printf(\"%s\\n\", c);\n  return 0;\n}\n"}
{"id": "EXP37-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/c3.c", "kind": "compliant", "text": "// EXP37-C: Compliant Solution\n/* In another source file */\n  \nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n \n/* f prototype in scope in this source file */\n \nlong f(long x);\n \nlong g(int x) {\n  return f((long)x); \n}\n"}
{"id": "EXP37-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/c4.c", "kind": "compliant", "text": "// EXP37-C: Compliant Solution (POSIX)\n#include <fcntl.h>\n  \nvoid func(const char *ms, mode_t perms) {\n  /* ... */\n  int fd;\n  fd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC, perms);\n  if (fd == -1) {\n    /* Handle error */\n  }\n}\n"}
{"id": "EXP37-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/nc0.c", "kind": "noncompliant", "text": "// EXP37-C: Noncompliant Code Example\n#include <tgmath.h>\n  \nvoid func(void) {\n  double complex c = 2.0 + 4.0 * I;\n  double complex result = log2(c);\n}\n"}
{"id": "EXP37-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/nc1.c", "kind": "noncompliant", "text": "// EXP37-C: Noncompliant Code Example\n#include <stdio.h>\n#include <string.h>\n \nchar *(*fp)();\n \nint main(void) {\n  const char *c;\n  fp = strchr;\n  c = fp('e', \"Hello\");\n  printf(\"%s\\n\", c);\n  return 0;\n}\n"}
{"id": "EXP37-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/nc2.c", "kind": "noncompliant", "text": "// EXP37-C: Noncompliant Code Example\n/* In another source file */\nlong f(long x) {\n  return x < 0 ? -x : x;\n}\n \n/* In this source file, no f prototype in scope */\nlong f();\n  \nlong g(int x) {\n  return f(x);\n}\n"}
{"id": "EXP37-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "EXP37-C", "file_path": "rules/exp/37/nc3.c", "kind": "noncompliant", "text": "// EXP37-C: Noncompliant Code Example (POSIX)\nfd = open(ms, O_CREAT | O_EXCL | O_WRONLY | O_TRUNC);\n"}
{"id": "FLP32-C_pdf_0", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "functions The C Standard, 7.12.1 [ISO/IEC 9899:2011], defines three types of errors that relate specifically to math functions in . Paragraph 2 states <math.h> A domain error occurs if an input argument is outside the domain over which the mathe- matical function is defined. Paragraph 3 states A pole error (also known as a singularity or infinitary) occurs if the mathematical function has an exact infinite result as the finite input argument(s) are approached in the limit. Paragraph 4 states A range error occurs if the mathematical result of the function cannot be represented in an object of the specified type, due to extreme magnitude. An example of a domain error is the square root of a negative number, such as , sqrt(-1.0) which has no meaning in real arithmetic. Contrastingly, 10 raised to the 1-millionth power, , cannot be represented in many floating-point implementations because of the pow(10., 1e6) limited range of the type and consequently constitutes a range error. In both cases, the double function will return some value, but the value returned is not the correct result of the computation. An example of a pole error is , which results in negative infinity. log(0.0) Programmers can prevent domain and pole errors by carefully bounds-checking the arguments be- fore calling mathematical functions and taking alternative action if the bounds are violated."}
{"id": "FLP32-C_pdf_1", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "Range errors usually cannot be prevented because they are dependent on the implementation of floating-point numbers as well as on the function being applied. Instead of preventing range er- rors, programmers should attempt to detect them and take alternative action if a range error oc- curs. The following table lists the forms of standard mathematical functions, along with checks double that should be performed to ensure a proper input domain, and indicates whether they can also re- sult in range or pole errors, as reported by the C Standard. Both and forms float long double of these functions also exist but are omitted from the table for brevity. If a function has a specific domain over which it is defined, the programmer must check its input values. The programmer must also check for range errors where they might occur. The standard math functions not listed in this table, such as , have no domain restrictions and cannot result in range or pole er- fabs() rors. SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 176 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Floating Point (FLP) - FLP32-C."}
{"id": "FLP32-C_pdf_2", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "Prevent or detect domain and range errors in math functions Function Domain Range Pole No No acos(x) -1 <= x && x <= 1 Yes No asin(x) -1 <= x && x <= 1 None Yes No atan(x) No No atan2(y, x) x != 0 && y != 0 Yes No acosh(x) x >= 1 None Yes No asinh(x) Yes Yes atanh(x) -1 < x && x < 1 , None Yes No cosh(x) sinh(x) , , None Yes No exp(x) exp2(x) expm1(x) None Yes No ldexp(x, exp) , , No Yes log(x) log10(x) x >= 0 log2(x) No Yes log1p(x) x >= -1 Yes No ilogb(x) x != 0 && !isinf(x) && !isnan(x) Yes Yes logb(x) x != 0 , None Yes No scalbn(x, n) scalbln(x, n) None Yes No hypot(x, y) Yes Yes pow(x,y) x > 0 || (x == 0 && y > 0) || ( is an integer) x < 0 && y No No sqrt(x) x >= 0 None Yes No erf(x) None Yes No erfc(x) , ( is an integer) Yes Yes lgamma(x) x != 0 &&! x < 0 && x tgamma(x) , None Yes No lrint(x) lround(x) , Yes No fmod(x, y) y != 0 , remainder(x, y) remquo(x, y, quo) , None Yes No nextafter(x, y) nexttoward(x, y) None Yes No fdim(x,y) None Yes No fma(x,y,z) SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 177 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Floating Point (FLP) - FLP32-C."}
{"id": "FLP32-C_pdf_3", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "Prevent or detect domain and range errors in math functions 6.2.1 Domain and Pole Checking The most reliable way to handle domain and pole errors is to prevent them by checking arguments beforehand, as in the following exemplar: double safe_sqrt(double x) { if (x < 0) { fprintf(stderr, \"sqrt requires a nonnegative argument\"); /* Handle domain / pole error */ } return sqrt (x); } 6.2.2 Range Checking Programmers usually cannot prevent range errors, so the most reliable way to handle them is to detect when they have occurred and act accordingly. The exact treatment of error conditions from math functions is tedious. The C Standard, 7.12.1 [ISO/IEC 9899:2011], defines the following behavior for floating-point overflow: A floating result overflows if the magnitude of the mathematical result is finite but so large that the mathematical result cannot be represented without extraordinary roundoff error in an object of the specified type. If a floating result overflows and default rounding is in effect, then the function returns the value of the macro , , or HUGE_VAL HUGE_VALF according to the return type, with the same sign as the correct value of the HUGE_VALL function; if the integer expression is nonzero, the math_errhandling & MATH_ERRNO integer expression acquires the value ; if the integer expression errno ERANGE is nonzero, the overflow floating-point ex- math_errhandling & MATH_ERREXCEPT ception is raised."}
{"id": "FLP32-C_pdf_4", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "It is preferable not to check for errors by comparing the returned value against or for HUGE_VAL 0 several reasons:  These are, in general, valid (albeit unlikely) data values.  Making such tests requires detailed knowledge of the various error returns for each math function.  Multiple results aside from HUGE_VAL and 0 are possible, and programmers must know which are possible in each case.  Different versions of the library have varied in their error-return behavior. It can be unreliable to check for math errors using because an implementation might not errno set . For real functions, the programmer determines if the implementation sets by errno errno checking whether is nonzero. For complex functions, the math_errhandling & MATH_ERRNO SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 178 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Floating Point (FLP) - FLP32-C. Prevent or detect domain and range errors in math functions C Standard, 7.3.2, paragraph 1, simply states that an implementation may set but is not errno required to [ISO/IEC 9899:2011]. The obsolete System V Interface Definition (SVID3) [UNIX 1992] provides more control over the treatment of errors in the math library. The programmer can define a function named matherr() that is invoked if errors occur in a math function."}
{"id": "FLP32-C_pdf_5", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "This function can print diagnostics, terminate the execution, or specify the desired return value. The function has not been adopted matherr() by C or POSIX, so it is not generally portable. The following error-handing template uses C Standard functions for floating-point errors when the C macro is defined and indicates that they should be used; otherwise, it math_errhandling examines : errno #include <math.h> #include <fenv.h> #include <errno.h> /* ... */ /* Use to call a math function and check errors */ { #pragma STDC FENV_ACCESS ON if (math_errhandling & MATH_ERREXCEPT) { feclearexcept(FE_ALL_EXCEPT); } errno = 0; /* Call the math function */ if ((math_errhandling & MATH_ERRNO) && errno != 0) { /* Handle range error */ } else if ((math_errhandling & MATH_ERREXCEPT) && fetestexcept(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW) != 0) { /* Handle range error */ } } See FLP03-C. Detect and handle floating-point errors for more details on how to detect floating- point errors. 6.2.3 Subnormal Numbers A subnormal number is a nonzero number that does not use all of its precision bits [IEEE 754 2006]. These numbers can be used to represent values that are closer to 0 than the smallest normal number (one that uses all of its precision bits)."}
{"id": "FLP32-C_pdf_6", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "However, the , , , asin() asinh() atan() , and functions may produce range errors, specifically when passed a subnormal atanh() erf() SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 179 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Floating Point (FLP) - FLP32-C. Prevent or detect domain and range errors in math functions number. When evaluated with a subnormal number, these functions can produce an inexact, sub- normal value, which is an underflow error. The C Standard, 7.12.1, paragraph 6 [ISO/IEC 9899:2011], defines the following behavior for floating-point underflow: The result underflows if the magnitude of the mathematical result is so small that the mathematical result cannot be represented, without extraordinary roundoff error, in an object of the specified type. If the result underflows, the function returns an implementa- tion-defined value whose magnitude is no greater than the smallest normalized positive number in the specified type; if the integer expression math_errhandling & is nonzero, whether acquires the value is implementa- MATH_ERRNO errno ERANGE tion-defined; if the integer expression & is non- math_errhandling MATH_ERREXCEPT zero, whether the underflow floating-point exception is raised is implementation-de- fined."}
{"id": "FLP32-C_pdf_7", "source": "CERT_PDF", "cert_rule": "FLP32-C", "title": "Prevent or detect domain and range errors in math", "kind": "description", "text": "Implementations that support floating-point arithmetic but do not support subnormal numbers, such as IBM S/360 hex floating-point or nonconforming IEEE-754 implementations that skip sub- normals (or support them by flushing them to zero), can return a range error when calling one of the following families of functions with the following arguments:  fmod((min+subnorm), min)  remainder((min+subnorm), min)  remquo((min+subnorm), min, quo) where is the minimum value for the corresponding floating point type and is a sub- min subnorm normal value. If Annex F is supported and subnormal results are supported, the returned value is exact and a range error cannot occur. The C Standard, F.10.7.1 [ISO/IEC 9899:2011], specifies the following for the , , and functions: fmod() remainder() remquo() When subnormal results are supported, the returned value is exact and is independent of the current rounding direction mode. Annex F, subclause F.10.7.2, paragraph 2, and subclause F.10.7.3, paragraph 2, of the C Standard identify when subnormal results are supported. 6.2.4"}
{"id": "FLP32-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/c0.c", "kind": "compliant", "text": "// FLP32-C: Compliant Solution (sqrt())\n#include <math.h>\n  \nvoid func(double x) {\n  double result;\n \n  if (isless(x, 0.0)) {\n    /* Handle domain error */\n  }\n \n  result = sqrt(x);\n}\n"}
{"id": "FLP32-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/c1.c", "kind": "compliant", "text": "// FLP32-C: Compliant Solution (sinh(), Range Errors)\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n  \nvoid func(double x) { \n  double result;\n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n \n    result = sinh(x);\n \n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n  \n  /* Use result... */\n}\n"}
{"id": "FLP32-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/c2.c", "kind": "compliant", "text": "// FLP32-C: Compliant Solution (pow())\n#include <math.h>\n#include <fenv.h>\n#include <errno.h>\n  \nvoid func(double x, double y) {\n  double result;\n \n  if (((x == 0.0f) && islessequal(y, 0.0)) || isless(x, 0.0)) {\n    /* Handle domain or pole error */\n  }\n \n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n \n    result = pow(x, y);\n  \n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n \n  /* Use result... */\n}\n"}
{"id": "FLP32-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/c3.c", "kind": "compliant", "text": "#include <math.h>\n#include <fenv.h>\n#include <errno.h>\nvoid func(float x) {\n  float result;\n \n  {\n    #pragma STDC FENV_ACCESS ON\n    if (math_errhandling & MATH_ERREXCEPT) {\n      feclearexcept(FE_ALL_EXCEPT);\n    }\n    errno = 0;\n \n    result = asin(x);\n \n    if ((math_errhandling & MATH_ERRNO) && errno != 0) {\n      /* Handle range error */\n    } else if ((math_errhandling & MATH_ERREXCEPT) &&\n               fetestexcept(FE_INVALID | FE_DIVBYZERO |\n                            FE_OVERFLOW | FE_UNDERFLOW) != 0) {\n      /* Handle range error */\n    }\n  }\n \n  /* Use result... */\n}\n"}
{"id": "FLP32-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/nc0.c", "kind": "noncompliant", "text": "// FLP32-C: Noncompliant Code Example (sqrt())\n#include <math.h>\n  \nvoid func(double x) {\n  double result;\n  result = sqrt(x);\n}\n"}
{"id": "FLP32-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/nc1.c", "kind": "noncompliant", "text": "// FLP32-C: Noncompliant Code Example (sinh(), Range Errors)\n#include <math.h>\n  \nvoid func(double x) {\n  double result;\n  result = sinh(x);\n}\n"}
{"id": "FLP32-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/nc2.c", "kind": "noncompliant", "text": "// FLP32-C: Noncompliant Code Example (pow())\n#include <math.h>\n  \nvoid func(double x, double y) {\n  double result;\n  result = pow(x, y);\n}\n"}
{"id": "FLP32-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "FLP32-C", "file_path": "rules/flp/32/nc3.c", "kind": "noncompliant", "text": "#include <math.h>\n  \nvoid func(float x) {\n  float result = asin(x);\n  /* ... */\n}\n"}
{"id": "FLP34-C_pdf_0", "source": "CERT_PDF", "cert_rule": "FLP34-C", "title": "Ensure that floating-point conversions are within range", "kind": "description", "text": "of the new type If a floating-point value is to be converted to a floating-point value of a smaller range and preci- sion or to an integer type, or if an integer type is to be converted to a floating-point type, the value must be representable in the destination type. The C Standard, 6.3.1.4, paragraph 1 [ISO/IEC 9899:2011], says, When a finite value of real floating type is converted to an integer type other than , _Bool the fractional part is discarded (i.e., the value is truncated toward zero). If the value of the integral part cannot be represented by the integer type, the behavior is undefined. Paragraph 2 of the same subclause says, When a value of integer type is converted to a real floating type, if the value being con- verted can be represented exactly in the new type, it is unchanged. If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, cho- sen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. And subclause 6.3.1.5, paragraph 1, says, When a value of real floating type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged."}
{"id": "FLP34-C_pdf_1", "source": "CERT_PDF", "cert_rule": "FLP34-C", "title": "Ensure that floating-point conversions are within range", "kind": "description", "text": "If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, cho- sen in an implementation-defined manner. If the value being converted is outside the range of values that can be represented, the behavior is undefined. See undefined behaviors 17 and 18. This rule does not apply to demotions of floating-point types on implementations that support signed infinity, such as IEEE 754, as all values are within range. 6.3.1"}
{"id": "FLP34-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "FLP34-C", "file_path": "rules/flp/34/c0.c", "kind": "compliant", "text": "// FLP34-C: Compliant Solution (float to int)\n#include <float.h>\n#include <limits.h>\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n  \nextern size_t popcount(uintmax_t); /* See INT35-C */\n#define PRECISION(umax_value) popcount(umax_value)\n  \nvoid func(float f_a) {\n  int i_a;\n  \n  if (isnan(f_a) ||\n      PRECISION(INT_MAX) < log2f(fabsf(f_a)) ||\n      (f_a != 0.0F && fabsf(f_a) < FLT_MIN)) {\n    /* Handle error */\n  } else {\n    i_a = f_a;\n  }\n}\n"}
{"id": "FLP34-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "FLP34-C", "file_path": "rules/flp/34/c1.c", "kind": "compliant", "text": "// FLP34-C: Compliant Solution (Narrowing Conversion)\n#include <float.h>\n#include <math.h>\n  \nvoid func(double d_a, long double big_d) {\n  double d_b;\n  float f_a;\n  float f_b;\n \n  if (d_a != 0.0 &&\n      (isnan(d_a) ||\n       isgreater(fabs(d_a), FLT_MAX) ||\n       isless(fabs(d_a), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_a = (float)d_a;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), FLT_MAX) ||\n       isless(fabs(big_d), FLT_MIN))) {\n    /* Handle error */\n  } else {\n    f_b = (float)big_d;\n  }\n  if (big_d != 0.0 &&\n      (isnan(big_d) ||\n       isgreater(fabs(big_d), DBL_MAX) ||\n       isless(fabs(big_d), DBL_MIN))) {\n    /* Handle error */\n  } else {\n    d_b = (double)big_d;\n  } \n}\n"}
{"id": "FLP34-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "FLP34-C", "file_path": "rules/flp/34/nc0.c", "kind": "noncompliant", "text": "// FLP34-C: Noncompliant Code Example (float to int)\nvoid func(float f_a) {\n  int i_a;\n  \n  /* Undefined if the integral part of f_a cannot be represented. */\n  i_a = f_a;\n}\n"}
{"id": "FLP34-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "FLP34-C", "file_path": "rules/flp/34/nc1.c", "kind": "noncompliant", "text": "// FLP34-C: Noncompliant Code Example (Narrowing Conversion)\nvoid func(double d_a, long double big_d) {\n  double d_b = (float)big_d;\n  float f_a = (float)d_a;\n  float f_b = (float)big_d;\n}\n"}
{"id": "INT30-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT30-C", "title": "Ensure that unsigned integer operations do not wrap", "kind": "description", "text": "The C Standard, 6.2.5, paragraph 9 [ISO/IEC 9899:2011], states A computation involving unsigned operands can never overflow, because a result that cannot be represented by the resulting unsigned integer type is reduced modulo the number that is one greater than the largest value that can be represented by the result- ing type. This behavior is more informally called unsigned integer wrapping. Unsigned integer operations can wrap if the resulting value cannot be represented by the underlying representation of the inte- ger. The following table indicates which operators can result in wrapping: Operator Wrap Operator Wrap Operator Wrap Operator Wrap + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= No & No >= No / No %= No | No <= No % No <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No un + No || No += Yes ^= No un - Yes ?: No The following sections examine specific operations that are susceptible to unsigned integer wrap. When operating on integer types with less precision than , integer promotions are applied. The int usual arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed. Programmers should understand integer conver- sion rules before trying to implement secure arithmetic operations. (See INT02-C."}
{"id": "INT30-C_pdf_1", "source": "CERT_PDF", "cert_rule": "INT30-C", "title": "Ensure that unsigned integer operations do not wrap", "kind": "description", "text": "Understand in- teger conversion rules.) Integer values must not be allowed to wrap, especially if they are used in any of the following ways:  Integer operands of any pointer arithmetic, including array indexing  The assignment expression for the declaration of a variable length array  The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 132 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Integers (INT) - INT30-C. Ensure that unsigned integer operations do not wrap  Function arguments of type size_t or rsize_t (for example, an argument to a memory al- location function)  In security-critical code The C Standard defines arithmetic on atomic integer types as read-modify-write operations with the same representation as regular integer types. As a result, wrapping of atomic unsigned integers is identical to regular unsigned integers and should also be prevented or detected. 5.1.1 Addition Addition is between two operands of arithmetic type or between a pointer to an object type and an integer type. This rule applies only to addition between two operands of arithmetic type. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object and ARR30-C."}
{"id": "INT30-C_pdf_2", "source": "CERT_PDF", "cert_rule": "INT30-C", "title": "Ensure that unsigned integer operations do not wrap", "kind": "description", "text": "Do not form or use out-of-bounds pointers or array subscripts.) Incrementing is equivalent to adding 1. 5.1.1.1"}
{"id": "INT30-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/c0.c", "kind": "compliant", "text": "// INT30-C: Compliant Solution (Precondition Test)\n#include <limits.h>\n  \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum;\n  if (UINT_MAX - ui_a < ui_b) {\n    /* Handle error */\n  } else {\n    usum = ui_a + ui_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/c1.c", "kind": "compliant", "text": "// INT30-C: Compliant Solution (Postcondition Test)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum = ui_a + ui_b;\n  if (usum < ui_a) {\n    /* Handle error */\n  }\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/c2.c", "kind": "compliant", "text": "// INT30-C: Compliant Solution (Precondition Test)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff;\n  if (ui_a < ui_b){\n    /* Handle error */\n  } else {\n    udiff = ui_a - ui_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/c3.c", "kind": "compliant", "text": "// INT30-C: Compliant Solution (Postcondition Test)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff = ui_a - ui_b;\n  if (udiff > ui_a) {\n    /* Handle error */\n  }\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/c4.c", "kind": "compliant", "text": "// INT30-C: Compliant Solution\npen->num_vertices = _cairo_pen_vertices_needed(\n  gstate->tolerance, radius, &gstate->ctm\n);\n \nif (pen->num_vertices > SIZE_MAX / sizeof(cairo_pen_vertex_t)) {\n  /* Handle error */\n}\npen->vertices = malloc(\n  pen->num_vertices * sizeof(cairo_pen_vertex_t)\n);\n"}
{"id": "INT30-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/nc0.c", "kind": "noncompliant", "text": "// INT30-C: Noncompliant Code Example\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int usum = ui_a + ui_b;\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/nc1.c", "kind": "noncompliant", "text": "// INT30-C: Noncompliant Code Example\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int udiff = ui_a - ui_b;\n  /* ... */\n}\n"}
{"id": "INT30-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "INT30-C", "file_path": "rules/int/30/nc2.c", "kind": "noncompliant", "text": "// INT30-C: Noncompliant Code Example\npen->num_vertices = _cairo_pen_vertices_needed(\n  gstate->tolerance, radius, &gstate->ctm\n);\npen->vertices = malloc(\n  pen->num_vertices * sizeof(cairo_pen_vertex_t)\n);\n"}
{"id": "INT31-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT31-C", "title": "Ensure that integer conversions do not result in lost or", "kind": "description", "text": "misinterpreted data Integer conversions, both implicit and explicit (using a cast), must be guaranteed not to result in lost or misinterpreted data. This rule is particularly true for integer values that originate from un- trusted sources and are used in any of the following ways:  Integer operands of any pointer arithmetic, including array indexing  The assignment expression for the declaration of a variable length array  The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object  Function arguments of type size_t or rsize_t (for example, an argument to a memory al- location function) This rule also applies to arguments passed to the following library functions that are converted to : unsigned char  memset()  memset_s()  fprintf() and related functions (For the length modifier c , if no l length modifier is pre- sent, the argument is converted to an , and the resulting character is int unsigned char written.)  fputc()  ungetc()  memchr() and to arguments to the following library functions that are converted to : char  strchr()  strrchr()  All of the functions listed in <ctype.h> The only integer type conversions that are guaranteed to be safe for all data values and all possible conforming implementations are conversions of an integral value to a wider type of the same sign- edness."}
{"id": "INT31-C_pdf_1", "source": "CERT_PDF", "cert_rule": "INT31-C", "title": "Ensure that integer conversions do not result in lost or", "kind": "description", "text": "The C Standard, subclause 6.3.1.3 [ISO/IEC 9899:2011], says When a value with integer type is converted to another integer type other than , if _Bool the value can be represented by the new type, it is unchanged. Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type. Otherwise, the new type is signed and the value cannot be represented in it; either the result is implementation-defined or an implementation-defined signal is raised. SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 138 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Integers (INT) - INT31-C. Ensure that integer conversions do not result in lost or misinterpreted data Typically, converting an integer to a smaller type results in truncation of the high-order bits. 5.2.1"}
{"id": "INT31-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c0.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (Unsigned to Signed)\n#include <limits.h>\n  \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  if (u_a <= SCHAR_MAX) {\n    sc = (signed char)u_a;  /* Cast eliminates warning */\n  } else {\n    /* Handle error */\n  }\n}\n"}
{"id": "INT31-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c1.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (Signed to Unsigned)\n#include <limits.h>\n \nvoid func(void) {\n  signed int si = INT_MIN;\n  unsigned int ui;\n  if (si < 0) {\n    /* Handle error */\n  } else {\n    ui = (unsigned int)si;  /* Cast eliminates warning */\n  }\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c2.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (Signed, Loss of Precision)\n#include <limits.h>\n \nvoid func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc;\n  if ((s_a < SCHAR_MIN) || (s_a > SCHAR_MAX)) {\n    /* Handle error */\n  } else {\n    sc = (signed char)s_a; /* Use cast to eliminate warning */\n  }\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c3.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (Unsigned, Loss of Precision)\n#include <limits.h>\n \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc;\n  if (u_a > UCHAR_MAX) {\n    /* Handle error */\n  } else {\n    uc = (unsigned char)u_a; /* Cast eliminates warning */\n  }\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c4.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (time_t Return Value)\n#include <time.h>\n  \nvoid func(void) {\n  time_t now = time(NULL);\n  if (now != (time_t)-1) {\n    /* Continue processing */\n  }\n}\n"}
{"id": "INT31-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/c5.c", "kind": "compliant", "text": "// INT31-C: Compliant Solution (memset())\n#include <string.h>\n#include <stddef.h>\n \nint *init_memory(int *array, size_t n) {\n  return memset(array, 0, n); \n} \n"}
{"id": "INT31-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc0.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (Unsigned to Signed)\n#include <limits.h>\n  \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  signed char sc;\n  sc = (signed char)u_a; /* Cast eliminates warning */\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc1.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (Signed to Unsigned)\n#include <limits.h>\n \nvoid func(void) {\n  signed int si = INT_MIN;\n  /* Cast eliminates warning */\n  unsigned int ui = (unsigned int)si;\n \n  /* ... */\n}\n"}
{"id": "INT31-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc2.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (Signed, Loss of Precision)\n#include <limits.h>\n \nvoid func(void) {\n  signed long int s_a = LONG_MAX;\n  signed char sc = (signed char)s_a; /* Cast eliminates warning */\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc3.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (Unsigned, Loss of Precision)\n#include <limits.h>\n \nvoid func(void) {\n  unsigned long int u_a = ULONG_MAX;\n  unsigned char uc = (unsigned char)u_a; /* Cast eliminates warning */\n  /* ... */\n}\n"}
{"id": "INT31-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc4.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (time_t Return Value)\n#include <time.h>\n  \nvoid func(void) {\n  time_t now = time(NULL);\n  if (now != -1) {\n    /* Continue processing */\n  }\n}\n"}
{"id": "INT31-C_samples_nc5.c", "source": "CERT_SAMPLES", "cert_rule": "INT31-C", "file_path": "rules/int/31/nc5.c", "kind": "noncompliant", "text": "// INT31-C: Noncompliant Code Example (memset())\n#include <string.h>\n#include <stddef.h>\n  \nint *init_memory(int *array, size_t n) {\n  return memset(array, 4096, n); \n} \n"}
{"id": "INT32-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT32-C", "title": "Ensure that operations on signed integers do not result in", "kind": "description", "text": "overflow Signed integer overflow is undefined behavior 36. Consequently, implementations have consider- able latitude in how they deal with signed integer overflow. (See MSC15-C. Do not depend on undefined behavior.) An implementation that defines signed integer types as being modulo, for example, need not detect integer overflow. Implementations may also trap on signed arithmetic overflows, or simply assume that overflows will never happen and generate object code accord- ingly. It is also possible for the same conforming implementation to emit code that exhibits dif- ferent behavior in different contexts. For example, an implementation may determine that a signed integer loop control variable declared in a local scope cannot overflow and may emit efficient code on the basis of that determination, while the same implementation may determine that a global variable used in a similar context will wrap. For these reasons, it is important to ensure that operations on signed integers do not result in over- flow."}
{"id": "INT32-C_pdf_1", "source": "CERT_PDF", "cert_rule": "INT32-C", "title": "Ensure that operations on signed integers do not result in", "kind": "description", "text": "Of particular importance are operations on signed integer values that originate from a tainted source and are used as  Integer operands of any pointer arithmetic, including array indexing  The assignment expression for the declaration of a variable length array  The postfix expression preceding square brackets [] or the expression in square brackets [] of a subscripted designation of an element of an array object  Function arguments of type size_t or rsize_t (for example, an argument to a memory al- location function) Integer operations will overflow if the resulting value cannot be represented by the underlying representation of the integer. The following table indicates which operations can result in over- flow. Operator Overflow Operator Overflow Operator Overflow Operator Overflow + Yes -= Yes << Yes < No - Yes *= Yes >> No > No * Yes /= Yes & No >= No / Yes %= Yes | No <= No % Yes <<= Yes ^ No == No ++ Yes >>= No ~ No != No -- Yes &= No ! No && No = No |= No unary + No || No += Yes ^= No unary - Yes ?: No The following sections examine specific operations that are susceptible to integer overflow. When operating on integer types with less precision than , integer promotions are applied. The usual int arithmetic conversions may also be applied to (implicitly) convert operands to equivalent types before arithmetic operations are performed."}
{"id": "INT32-C_pdf_2", "source": "CERT_PDF", "cert_rule": "INT32-C", "title": "Ensure that operations on signed integers do not result in", "kind": "description", "text": "Programmers should understand integer conversion SEI CERT C Coding Standard: Rules for Developing Safe, Reliable, and Secure Systems 147 Software Engineering Institute | Carnegie Mellon University [DISTRIBUTION STATEMENT A] Approved for public release and unlimited distribution. Integers (INT) - INT32-C. Ensure that operations on signed integers do not result in overflow rules before trying to implement secure arithmetic operations. (See INT02-C. Understand integer conversion rules.) 5.3.1 Implementation Details GNU GCC invoked with the command-line option defines the same modulo arithmetic -fwrapv for both unsigned and signed integers. GNU GCC invoked with the command-line option causes a trap to be generated when a -ftrapv signed integer overflows, which will most likely abnormally exit. On a UNIX system, the result of such an event may be a signal sent to the process. GNU GCC invoked without either the or the option may simply assume that -fwrapv -ftrapv signed integers never overflow and may generate object code accordingly. 5.3.2 Atomic Integers The C Standard defines the behavior of arithmetic on atomic signed integer types to use twos complement representation with silent wraparound on overflow; there are no undefined results. Although defined, these results may be unexpected and therefore carry similar risks to unsigned integer wrapping. (See INT30-C."}
{"id": "INT32-C_pdf_3", "source": "CERT_PDF", "cert_rule": "INT32-C", "title": "Ensure that operations on signed integers do not result in", "kind": "description", "text": "Ensure that unsigned integer operations do not wrap.) Conse- quently, signed integer overflow of atomic integer types should also be prevented or detected. 5.3.3 Addition Addition is between two operands of arithmetic type or between a pointer to an object type and an integer type. This rule applies only to addition between two operands of arithmetic type. (See ARR37-C. Do not add or subtract an integer to a pointer to a non-array object and ARR30-C. Do not form or use out-of-bounds pointers or array subscripts.) Incrementing is equivalent to adding 1. 5.3.3.1"}
{"id": "INT32-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c0.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid f(signed int si_a, signed int si_b) {\n  signed int sum;\n  if (((si_b > 0) && (si_a > (INT_MAX - si_b))) ||\n      ((si_b < 0) && (si_a < (INT_MIN - si_b)))) {\n    /* Handle error */\n  } else {\n    sum = si_a + si_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c1.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed int si_a, signed int si_b) {\n  signed int diff;\n  if ((si_b > 0 && si_a < INT_MIN + si_b) ||\n      (si_b < 0 && si_a > INT_MAX + si_b)) {\n    /* Handle error */\n  } else {\n    diff = si_a - si_b;\n  }\n \n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c2.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <stddef.h>\n#include <assert.h>\n#include <limits.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n   \nvoid func(signed int si_a, signed int si_b) {\n  signed int result;\n  signed long long tmp;\n  assert(PRECISION(ULLONG_MAX) >= 2 * PRECISION(UINT_MAX));\n  tmp = (signed long long)si_a * (signed long long)si_b;\n  \n  /*\n   * If the product cannot be represented as a 32-bit integer,\n   * handle as an error condition.\n   */\n  if ((tmp > INT_MAX) || (tmp < INT_MIN)) {\n    /* Handle error */\n  } else {\n    result = (int)tmp;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c3.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed int si_a, signed int si_b) {\n  signed int result; \n  if (si_a > 0) {  /* si_a is positive */\n    if (si_b > 0) {  /* si_a and si_b are positive */\n      if (si_a > (INT_MAX / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a positive, si_b nonpositive */\n      if (si_b < (INT_MIN / si_a)) {\n        /* Handle error */\n      }\n    } /* si_a positive, si_b nonpositive */\n  } else { /* si_a is nonpositive */\n    if (si_b > 0) { /* si_a is nonpositive, si_b is positive */\n      if (si_a < (INT_MIN / si_b)) {\n        /* Handle error */\n      }\n    } else { /* si_a and si_b are nonpositive */\n      if ( (si_a != 0) && (si_b < (INT_MAX / si_a))) {\n        /* Handle error */\n      }\n    } /* End if si_a and si_b are nonpositive */\n  } /* End if si_a is nonpositive */\n \n  result = si_a * si_b;\n}\n"}
{"id": "INT32-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c4.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c5.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  } \n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c6.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c6.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_c7.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/c7.c", "kind": "compliant", "text": "// INT32-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a) {\n  signed long result;\n  if (s_a == LONG_MIN) {\n    /* Handle error */\n  } else {\n    result = -s_a;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc0.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int sum = si_a + si_b;\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc1.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int diff = si_a - si_b;\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc2.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed int si_a, signed int si_b) {\n  signed int result = si_a * si_b;\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc3.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc4.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if (s_b == 0) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc5.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc5.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value)\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT32-C_samples_nc6.c", "source": "CERT_SAMPLES", "cert_rule": "INT32-C", "file_path": "rules/int/32/nc6.c", "kind": "noncompliant", "text": "// INT32-C: Noncompliant Code Example\nvoid func(signed long s_a) {\n  signed long result = -s_a;\n  /* ... */\n}\n"}
{"id": "INT33-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT33-C", "title": "Ensure that division and remainder operations do not", "kind": "description", "text": "result in divide-by-zero errors The C Standard identifies the following condition under which division and remainder operations result in undefined behavior (UB): UB Description 45 The value of the second operand of the / or % opera- tor is zero (6.5.5). Ensure that division and remainder operations do not result in divide-by-zero errors. 5.4.1 Division The result of the operator is the quotient from the division of the first arithmetic operand by the / second arithmetic operand. Division operations are susceptible to divide-by-zero errors. Overflow can also occur during twos complement signed integer division when the dividend is equal to the minimum (most negative) value for the signed integer type and the divisor is equal to (See 1. INT32-C. Ensure that operations on signed integers do not result in overflow.) 5.4.1.1"}
{"id": "INT33-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT33-C", "file_path": "rules/int/33/c0.c", "kind": "compliant", "text": "// INT33-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT33-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "INT33-C", "file_path": "rules/int/33/c1.c", "kind": "compliant", "text": "// INT33-C: Compliant Solution\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_b == 0 ) || ((s_a == LONG_MIN) && (s_b == -1))) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT33-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT33-C", "file_path": "rules/int/33/nc0.c", "kind": "noncompliant", "text": "// INT33-C: Noncompliant Code Example\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_a == LONG_MIN) && (s_b == -1)) {\n    /* Handle error */\n  } else {\n    result = s_a / s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT33-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "INT33-C", "file_path": "rules/int/33/nc1.c", "kind": "noncompliant", "text": "// INT33-C: Noncompliant Code Example\n#include <limits.h>\n  \nvoid func(signed long s_a, signed long s_b) {\n  signed long result;\n  if ((s_a == LONG_MIN) && (s_b == -1)) {\n    /* Handle error */\n  } else {\n    result = s_a % s_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT34-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT34-C", "title": "Do not shift an expression by a negative number of bits or", "kind": "description", "text": "by greater than or equal to the number of bits that exist in the operand Bitwise shifts include left-shift operations of the form shift-expression additive-expression and << right-shift operations of the form shift-expression additive-expression. The standard integer pro- >> motions are first performed on the operands, each of which has an integer type. The type of the result is that of the promoted left operand. If the value of the right operand is negative or is greater than or equal to the width of the promoted left operand, the behavior is undefined. (See undefined behavior 51.) Do not shift an expression by a negative number of bits or by a number greater than or equal to the precision of the promoted left operand. The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. For unsigned integer types, the width and the precision are the same; whereas for signed integer types, the width is one greater than the precision. This rule uses precision instead of width because, in almost every case, an at- tempt to shift by a number of bits greater than or equal to the precision of the operand indicates a bug (logic error). A logic error is different from overflow, in which there is simply a representa- tional deficiency. In general, shifts should be performed only on unsigned operands. (See INT13- C. Use bitwise operators only on unsigned operands.) 5.5.1"}
{"id": "INT34-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/c0.c", "kind": "compliant", "text": "// INT34-C: Compliant Solution (Left Shift, Unsigned Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a << ui_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT34-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/c1.c", "kind": "compliant", "text": "// INT34-C: Compliant Solution (Left Shift, Signed Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n  \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if ((si_a < 0) || (si_b < 0) ||\n      (si_b >= PRECISION(ULONG_MAX)) ||\n      (si_a > (LONG_MAX >> si_b))) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT34-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/c2.c", "kind": "compliant", "text": "// INT34-C: Compliant Solution (Right Shift)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nextern size_t popcount(uintmax_t);\n#define PRECISION(x) popcount(x)\n  \nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = 0;\n  if (ui_b >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  } else {\n    uresult = ui_a >> ui_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT34-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/nc0.c", "kind": "noncompliant", "text": "// INT34-C: Noncompliant Code Example (Left Shift, Unsigned Type)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a << ui_b;\n  /* ... */\n}\n"}
{"id": "INT34-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/nc1.c", "kind": "noncompliant", "text": "// INT34-C: Noncompliant Code Example (Left Shift, Signed Type)\n#include <limits.h>\n#include <stddef.h>\n#include <inttypes.h>\n \nvoid func(signed long si_a, signed long si_b) {\n  signed long result;\n  if (si_a > (LONG_MAX >> si_b)) {\n    /* Handle error */\n  } else {\n    result = si_a << si_b;\n  }\n  /* ... */\n}\n"}
{"id": "INT34-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "INT34-C", "file_path": "rules/int/34/nc2.c", "kind": "noncompliant", "text": "// INT34-C: Noncompliant Code Example (Right Shift)\nvoid func(unsigned int ui_a, unsigned int ui_b) {\n  unsigned int uresult = ui_a >> ui_b;\n  /* ... */\n}\n"}
{"id": "INT35-C_pdf_0", "source": "CERT_PDF", "cert_rule": "INT35-C", "title": "Use correct integer precisions", "kind": "description", "text": "Integer types in C have both a size and a precision. The size indicates the number of bytes used by an object and can be retrieved for any object or type using the operator. The precision of sizeof an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. Padding bits contribute to the integers size, but not to its precision. Consequently, inferring the precision of an integer type from its size may result in too large a value, which can then lead to incorrect assumptions about the numeric range of these types. Programmers should use correct integer precisions in their code, and in particular, should not use the operator to compute sizeof the precision of an integer type on architectures that use padding bits or in strictly conforming (that is, portable) programs. 5.6.1"}
{"id": "INT35-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "INT35-C", "file_path": "rules/int/35/c0.c", "kind": "compliant", "text": "// INT35-C: Compliant Solution\n#include <stddef.h>\n#include <stdint.h>\n  \n/* Returns the number of set bits */\nsize_t popcount(uintmax_t num) {\n  size_t precision = 0;\n  while (num != 0) {\n    if (num % 2 == 1) {\n      precision++;\n    }\n    num >>= 1;\n  }\n  return precision;\n}\n#define PRECISION(umax_value) popcount(umax_value)\n"}
{"id": "INT35-C_samples_c1-a.c", "source": "CERT_SAMPLES", "cert_rule": "INT35-C", "file_path": "rules/int/35/c1-a.c", "kind": "compliant", "text": "// INT35-C: Compliant Solution\n#define PRECISION(value)  _Generic(value, \\\n  unsigned char : 8, \\\n  unsigned short: 16, \\\n  unsigned int : 32, \\\n  unsigned long : 32, \\\n  unsigned long long : 64, \\\n  signed char : 7, \\\n  signed short : 15, \\\n  signed int : 31, \\\n  signed long : 31, \\\n  signed long long : 63)\n"}
{"id": "INT35-C_samples_c1-b.c", "source": "CERT_SAMPLES", "cert_rule": "INT35-C", "file_path": "rules/int/35/c1-b.c", "kind": "compliant", "text": "// INT35-C: Compliant Solution\n#include <stddef.h>\n#include <stdint.h>\n#include <limits.h>\nextern size_t popcount(uintmax_t);\n#define PRECISION(umax_value) popcount(umax_value) \nunsigned int pow2(unsigned int exp) {\n  if (exp >= PRECISION(UINT_MAX)) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\n"}
{"id": "INT35-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "INT35-C", "file_path": "rules/int/35/nc0.c", "kind": "noncompliant", "text": "// INT35-C: Noncompliant Code Example\n#include <limits.h>\n  \nunsigned int pow2(unsigned int exp) {\n  if (exp >= sizeof(unsigned int) * CHAR_BIT) {\n    /* Handle error */\n  }\n  return 1 << exp;\n}\n"}
{"id": "MEM30-C_pdf_0", "source": "CERT_PDF", "cert_rule": "MEM30-C", "title": "Do not access freed memory", "kind": "description", "text": "Evaluating a pointerincluding dereferencing the pointer, using it as an operand of an arithmetic operation, type casting it, and using it as the right-hand side of an assignmentinto memory that has been deallocated by a memory management function is undefined behavior. Pointers to memory that has been deallocated are called dangling pointers. Accessing a dangling pointer can result in exploitable vulnerabilities. According to the C Standard, using the value of a pointer that refers to space deallocated by a call to the or function is undefined behavior. (See undefined behavior 177.) free() realloc() Reading a pointer to deallocated memory is undefined behavior because the pointer value is inde- terminate and might be a trap representation. Fetching a trap representation might perform a hard- ware trap (but is not required to). It is at the memory managers discretion when to reallocate or recycle the freed memory. When memory is freed, all pointers into it become invalid, and its contents might either be returned to the operating system, making the freed space inaccessible, or remain intact and accessible. As a result, the data at the freed location can appear to be valid but change unexpectedly. Conse- quently, memory must not be written to or read from once it is freed. 9.1.1"}
{"id": "MEM30-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/c0.c", "kind": "compliant", "text": "// MEM30-C: Compliant Solution\n#include <stdlib.h>\n  \nstruct node {\n  int value;\n  struct node *next;\n};\n  \nvoid free_list(struct node *head) {\n  struct node *q;\n  for (struct node *p = head; p != NULL; p = q) {\n    q = p->next;\n    free(p);\n  }\n}\n"}
{"id": "MEM30-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/c1.c", "kind": "compliant", "text": "// MEM30-C: Compliant Solution\n#include <stdlib.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  free(buf);\n  return EXIT_SUCCESS;\n}\n"}
{"id": "MEM30-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/c2.c", "kind": "compliant", "text": "// MEM30-C: Compliant Solution\n#include <stdlib.h>\n  \nvoid f(char *c_str1, size_t size) {\n  if (size != 0) {\n    char *c_str2 = (char *)realloc(c_str1, size);\n    if (c_str2 == NULL) {\n      free(c_str1);\n    }\n  }\n  else {\n    free(c_str1);\n  }\n  \n}\n"}
{"id": "MEM30-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/c3.c", "kind": "compliant", "text": "// MEM30-C: Compliant Solution\nvoid gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n    /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    if (more == 0) return;\n    im->clip->max += 8;\n    im->clip->list = more;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n \n}\n"}
{"id": "MEM30-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/nc0.c", "kind": "noncompliant", "text": "// MEM30-C: Noncompliant Code Example\n#include <stdlib.h>\n  \nstruct node {\n  int value;\n  struct node *next;\n};\n  \nvoid free_list(struct node *head) {\n  for (struct node *p = head; p != NULL; p = p->next) {\n    free(p);\n  }\n}\n"}
{"id": "MEM30-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/nc1.c", "kind": "noncompliant", "text": "// MEM30-C: Noncompliant Code Example\n#include <stdlib.h>\n#include <string.h>\n \nint main(int argc, char *argv[]) {\n  char *return_val = 0;\n  const size_t bufsize = strlen(argv[0]) + 1;\n  char *buf = (char *)malloc(bufsize);\n  if (!buf) {\n    return EXIT_FAILURE;\n  }\n  /* ... */\n  free(buf);\n  /* ... */\n  strcpy(buf, argv[0]);\n  /* ... */\n  return EXIT_SUCCESS;\n}\n"}
{"id": "MEM30-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/nc2.c", "kind": "noncompliant", "text": "// MEM30-C: Noncompliant Code Example\n#include <stdlib.h>\n  \nvoid f(char *c_str1, size_t size) {\n  char *c_str2 = (char *)realloc(c_str1, size);\n  if (c_str2 == NULL) {\n    free(c_str1);\n  }\n}\n"}
{"id": "MEM30-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "MEM30-C", "file_path": "rules/mem/30/nc3.c", "kind": "noncompliant", "text": "// MEM30-C: Noncompliant Code Example\nvoid gdClipSetAdd(gdImagePtr im, gdClipRectanglePtr rect) {\n  gdClipRectanglePtr more;\n  if (im->clip == 0) {\n   /* ... */\n  }\n  if (im->clip->count == im->clip->max) {\n    more = gdRealloc (im->clip->list,(im->clip->max + 8) *\n                      sizeof (gdClipRectangle));\n    /*\n     * If the realloc fails, then we have not lost the\n     * im->clip->list value.\n     */\n    if (more == 0) return;\n    im->clip->max += 8;\n  }\n  im->clip->list[im->clip->count] = *rect;\n  im->clip->count++;\n \n}\n"}
{"id": "MEM31-C_pdf_0", "source": "CERT_PDF", "cert_rule": "MEM31-C", "title": "Free dynamically allocated memory when no longer", "kind": "description", "text": "needed Before the lifetime of the last pointer that stores the return value of a call to a standard memory allocation function has ended, it must be matched by a call to with that pointer value. free() 9.2.1"}
{"id": "MEM31-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM31-C", "file_path": "rules/mem/31/c0.c", "kind": "compliant", "text": "// MEM31-C: Compliant Solution\n#include <stdlib.h>\n \nenum { BUFFER_SIZE = 32 };\n \nint f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE);\n  if (text_buffer == NULL) {\n    return -1;\n  }\n  \n  free(text_buffer);\n  return 0;\n}\n"}
{"id": "MEM31-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM31-C", "file_path": "rules/mem/31/nc0.c", "kind": "noncompliant", "text": "// MEM31-C: Noncompliant Code Example\n#include <stdlib.h>\n  \nenum { BUFFER_SIZE = 32 };\n \nint f(void) {\n  char *text_buffer = (char *)malloc(BUFFER_SIZE);\n  if (text_buffer == NULL) {\n    return -1;\n  }\n  return 0;\n}\n"}
{"id": "MEM34-C_pdf_0", "source": "CERT_PDF", "cert_rule": "MEM34-C", "title": "Only free memory allocated dynamically", "kind": "description", "text": "The C Standard, Annex J [ISO/IEC 9899:2011], states that the behavior of a program is undefined when The pointer argument to the or function does not match a pointer earlier free realloc returned by a memory management function, or the space has been deallocated by a call to or . free realloc See also undefined behavior 179. Freeing memory that is not allocated dynamically can result in heap corruption and other serious errors. Do not call on a pointer other than one returned by a standard memory allocation free() function, such as , , , or . malloc() calloc() realloc() aligned_alloc() A similar situation arises when is supplied a pointer to non-dynamically allocated realloc() memory. The function is used to resize a block of dynamic memory. If realloc() realloc() is supplied a pointer to memory not allocated by a standard memory allocation function, the be- havior is undefined. One consequence is that the program may terminate abnormally. This rule does not apply to null pointers. The C Standard guarantees that if is passed a free() null pointer, no action occurs. 9.4.1"}
{"id": "MEM34-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM34-C", "file_path": "rules/mem/34/c0.c", "kind": "compliant", "text": "// MEM34-C: Compliant Solution\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  \nenum { MAX_ALLOCATION = 1000 };\n \nint main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n \n  if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    printf(\"%s\\n\", \"usage: $>a.exe [string]\");\n    return EXIT_FAILURE;\n  }\n  free(c_str);\n  return 0;\n}\n"}
{"id": "MEM34-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM34-C", "file_path": "rules/mem/34/c1.c", "kind": "compliant", "text": "// MEM34-C: Compliant Solution (realloc())\n#include <stdlib.h>\n  \nenum { BUFSIZE = 256 };\n  \nvoid f(void) {\n  char *buf = (char *)malloc(BUFSIZE * sizeof(char));\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}\n"}
{"id": "MEM34-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM34-C", "file_path": "rules/mem/34/nc0.c", "kind": "noncompliant", "text": "// MEM34-C: Noncompliant Code Example\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n  \nenum { MAX_ALLOCATION = 1000 };\n \nint main(int argc, const char *argv[]) {\n  char *c_str = NULL;\n  size_t len;\n \n  if (argc == 2) {\n    len = strlen(argv[1]) + 1;\n    if (len > MAX_ALLOCATION) {\n      /* Handle error */\n    }\n    c_str = (char *)malloc(len);\n    if (c_str == NULL) {\n      /* Handle error */\n    }\n    strcpy(c_str, argv[1]);\n  } else {\n    c_str = \"usage: $>a.exe [string]\";\n    printf(\"%s\\n\", c_str);\n  }\n  free(c_str);\n  return 0;\n}\n"}
{"id": "MEM34-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM34-C", "file_path": "rules/mem/34/nc1.c", "kind": "noncompliant", "text": "// MEM34-C: Noncompliant Code Example (realloc())\n#include <stdlib.h>\n  \nenum { BUFSIZE = 256 };\n  \nvoid f(void) {\n  char buf[BUFSIZE];\n  char *p = (char *)realloc(buf, 2 * BUFSIZE);\n  if (p == NULL) {\n    /* Handle error */\n  }\n}\n"}
{"id": "MEM35-C_pdf_0", "source": "CERT_PDF", "cert_rule": "MEM35-C", "title": "Allocate sufficient memory for an object", "kind": "description", "text": "The types of integer expressions used as size arguments to , , , malloc() calloc() realloc() or must have sufficient range to represent the size of the objects to be stored. aligned_alloc() If size arguments are incorrect or can be manipulated by an attacker, then a buffer overflow may occur. Incorrect size arguments, inadequate range checking, integer overflow, or truncation can result in the allocation of an inadequately sized buffer. Typically, the amount of memory to allocate will be the size of the type of object to allocate. When allocating space for an array, the size of the object will be multiplied by the bounds of the array. When allocating space for a structure containing a flexible array member, the size of the ar- ray member must be added to the size of the structure. (See MEM33-C. Allocate and copy struc- tures containing a flexible array member dynamically.) Use the correct type of the object when computing the size of memory to allocate. STR31-C. Guarantee that storage for strings has sufficient space for character data and the null terminator is a specific instance of this rule. 9.5.1"}
{"id": "MEM35-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM35-C", "file_path": "rules/mem/35/c0.c", "kind": "compliant", "text": "// MEM35-C: Compliant Solution (Pointer)\n#include <stdlib.h>\n#include <time.h>\n  \nstruct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(*tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}\n"}
{"id": "MEM35-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM35-C", "file_path": "rules/mem/35/c1.c", "kind": "compliant", "text": "// MEM35-C: Compliant Solution (Integer)\n#include <stdint.h>\n#include <stdlib.h>\n \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(long));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n"}
{"id": "MEM35-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "MEM35-C", "file_path": "rules/mem/35/c2.c", "kind": "compliant", "text": "// MEM35-C: Compliant Solution (Integer)\n#include <stdint.h>\n#include <stdlib.h>\n  \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(*p)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(*p));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n"}
{"id": "MEM35-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "MEM35-C", "file_path": "rules/mem/35/nc0.c", "kind": "noncompliant", "text": "// MEM35-C: Noncompliant Code Example (Pointer)\n#include <stdlib.h>\n#include <time.h>\n  \nstruct tm *make_tm(int year, int mon, int day, int hour,\n                   int min, int sec) {\n  struct tm *tmb;\n  tmb = (struct tm *)malloc(sizeof(tmb));\n  if (tmb == NULL) {\n    return NULL;\n  }\n  *tmb = (struct tm) {\n    .tm_sec = sec, .tm_min = min, .tm_hour = hour,\n    .tm_mday = day, .tm_mon = mon, .tm_year = year\n  };\n  return tmb;\n}\n"}
{"id": "MEM35-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "MEM35-C", "file_path": "rules/mem/35/nc1.c", "kind": "noncompliant", "text": "// MEM35-C: Noncompliant Code Example (Integer)\n#include <stdint.h>\n#include <stdlib.h>\n  \nvoid function(size_t len) {\n  long *p;\n  if (len == 0 || len > SIZE_MAX / sizeof(long)) {\n    /* Handle overflow */\n  }\n  p = (long *)malloc(len * sizeof(int));\n  if (p == NULL) {\n    /* Handle error */\n  }\n  free(p);\n}\n"}
{"id": "MSC37-C_pdf_0", "source": "CERT_PDF", "cert_rule": "MSC37-C", "title": "Ensure that control never reaches the end of a non-void", "kind": "description", "text": "function If control reaches the closing curly brace ( ) of a non- function without evaluating a } void return statement, using the return value of the function call is undefined behavior. (See undefined behav- ior 88.) 15.4.1"}
{"id": "MSC37-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "MSC37-C", "file_path": "rules/msc/37/c0.c", "kind": "compliant", "text": "// MSC37-C: Compliant Solution\n#include <string.h>\n#include <stdio.h>\n  \nint checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n  return 0;\n}\n \nvoid func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success!\\n\");\n  }\n}\n"}
{"id": "MSC37-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "MSC37-C", "file_path": "rules/msc/37/c1.c", "kind": "compliant", "text": "// MSC37-C: Compliant Solution\n#include <stddef.h>\n  \nint getlen(const int *input, size_t maxlen, int delim,\n           size_t *result) {\n  if (result == NULL) {\n    return -1;\n  }\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      *result = i;\n      return 0;\n    }\n  }\n  return -1;\n}\n \nvoid func(int userdata) {\n  size_t i;\n  int data[] = {1, 1, 1};\n  if (getlen(data, sizeof(data), 0, &i) != 0) {\n    /* Handle error */\n  } else {\n    data[i] = userdata;\n  }\n}\n"}
{"id": "MSC37-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "MSC37-C", "file_path": "rules/msc/37/nc0.c", "kind": "noncompliant", "text": "// MSC37-C: Noncompliant Code Example\n#include <string.h>\n#include <stdio.h>\n  \nint checkpass(const char *password) {\n  if (strcmp(password, \"pass\") == 0) {\n    return 1;\n  }\n}\n \nvoid func(const char *userinput) {\n  if (checkpass(userinput)) {\n    printf(\"Success\\n\");\n  }\n}\n"}
{"id": "MSC37-C_samples_nc1-a.c", "source": "CERT_SAMPLES", "cert_rule": "MSC37-C", "file_path": "rules/msc/37/nc1-a.c", "kind": "noncompliant", "text": "// MSC37-C: Noncompliant Code Example\n#include <stddef.h>\n  \nsize_t getlen(const int *input, size_t maxlen, int delim) {\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      return i;\n    }\n  }\n}\n  \nvoid func(int userdata) {\n  size_t i;\n  int data[] = { 1, 1, 1 };\n  i = getlen(data, sizeof(data), 0);\n  data[i] = userdata;\n}\n"}
{"id": "MSC37-C_samples_nc1-b.c", "source": "CERT_SAMPLES", "cert_rule": "MSC37-C", "file_path": "rules/msc/37/nc1-b.c", "kind": "noncompliant", "text": "// MSC37-C: Noncompliant Code Example\n#include <stdio.h>\n \nsize_t getlen(const int *input, size_t maxlen, int delim) {\n  for (size_t i = 0; i < maxlen; ++i) {\n    if (input[i] == delim) {\n      return i;\n    }\n  }\n}\n \nint main(int argc, char **argv) {\n  size_t i;\n  int data[] = { 1, 1, 1 };\n \n  i = getlen(data, sizeof(data), 0);\n  printf(\"Returned: %zu\\n\", i);\n  data[i] = 0;\n \n  return 0;\n}\n"}
{"id": "STR31-C_pdf_0", "source": "CERT_PDF", "cert_rule": "STR31-C", "title": "Guarantee that storage for strings has sufficient space", "kind": "description", "text": "for character data and the null terminator Copying data to a buffer that is not large enough to hold that data results in a buffer overflow. Buffer overflows occur frequently when manipulating strings [Seacord 2013b]. To prevent such errors, either limit copies through truncation or, preferably, ensure that the destination is of suffi- cient size to hold the character data to be copied and the null-termination character. (See STR03- C. Do not inadvertently truncate a string.) When strings live on the heap, this rule is a specific instance of MEM35-C. Allocate sufficient memory for an object. Because strings are represented as arrays of characters, this rule is related to both ARR30-C. Do not form or use out-of-bounds pointers or array subscripts and ARR38-C. Guarantee that library functions do not form invalid pointers. 8.2.1"}
{"id": "STR31-C_samples_c0.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c0.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (Off-by-One Error)\n#include <stddef.h>\n  \nvoid copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n  \n   for (i = 0; src[i] && (i < n - 1); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\n"}
{"id": "STR31-C_samples_c1.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c1.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (fgets())\n#include <stdio.h>\n#include <string.h>\n  \nenum { BUFFERSIZE = 32 };\n  \nvoid func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n \n  if (fgets(buf, sizeof(buf), stdin)) {\n    /* fgets() succeeded; scan for newline character */\n    char *p = strchr(buf, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n        ;\n      if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n          /* Character resembles EOF; handle error */\n      }\n    }\n  } else {\n    /* fgets() failed; handle error */\n  }\n}\n"}
{"id": "STR31-C_samples_c10.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c10.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (sprintf())\n#include <stdio.h>\n  \nvoid func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%.123s.txt\", name);\n}\n"}
{"id": "STR31-C_samples_c11.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c11.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (snprintf())\n#include <stdio.h>\n  \nvoid func(const char *name) {\n  char filename[128];\n  snprintf(filename, sizeof(filename), \"%s.txt\", name);\n}\n"}
{"id": "STR31-C_samples_c2.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c2.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (gets_s())\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdio.h>\n  \nenum { BUFFERSIZE = 32 };\n  \nvoid func(void) {\n  char buf[BUFFERSIZE];\n \n  if (gets_s(buf, sizeof(buf)) == NULL) {\n    /* Handle error */\n  }\n}\n"}
{"id": "STR31-C_samples_c3.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c3.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (getline(), POSIX)\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n  \nvoid func(void) {\n  int ch;\n  size_t buffer_size = 32;\n  char *buffer = malloc(buffer_size);\n  \n  if (!buffer) {\n    /* Handle error */\n    return;\n  }\n \n  if ((ssize_t size = getline(&buffer, &buffer_size, stdin))\n        == -1) {\n    /* Handle error */\n  } else {\n    char *p = strchr(buffer, '\\n');\n    if (p) {\n      *p = '\\0';\n    } else {\n      /* Newline not found; flush stdin to end of line */\n      while ((ch = getchar()) != '\\n' && ch != EOF)\n        ;\n      if (ch == EOF && !feof(stdin) && !ferror(stdin)) {\n         /* Character resembles EOF; handle error */\n      }\n    }\n  }\n  free (buffer);\n}\n"}
{"id": "STR31-C_samples_c4.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c4.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (getchar())\n#include <stdio.h>\n  \nenum { BUFFERSIZE = 32 };\n  \nvoid func(void) {\n  char buf[BUFFERSIZE];\n  int ch;\n  size_t index = 0;\n  size_t chars_read = 0;\n  \n  while ((ch = getchar()) != '\\n' && ch != EOF) {\n    if (index < sizeof(buf) - 1) {\n      buf[index++] = (char)ch;\n    }\n    chars_read++;\n  }\n  buf[index] = '\\0';  /* Terminate string */\n  if (ch == EOF) {\n    /* Handle EOF or error */\n  }\n  if (chars_read > index) {\n    /* Handle truncation */\n  }\n}\n"}
{"id": "STR31-C_samples_c5.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c5.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (fscanf())\n#include <stdio.h>\n  \nenum { BUF_LENGTH = 1024 };\n  \nvoid get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%1023s\", buf)) {\n    /* Handle error */\n  }\n \n  /* Rest of function */\n}\n"}
{"id": "STR31-C_samples_c6.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c6.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (argv)\n#include <stdlib.h>\n#include <string.h>\n  \nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name = (char *)malloc(strlen(name) + 1);\n  if (prog_name != NULL) {\n    strcpy(prog_name, name);\n  } else {\n    /* Handle error */\n  }\n  free(prog_name);\n  return 0;\n}\n"}
{"id": "STR31-C_samples_c7.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c7.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (argv)\n#define __STDC_WANT_LIB_EXT1__ 1\n#include <stdlib.h>\n#include <string.h>\n  \nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char *prog_name;\n  size_t prog_size;\n \n  prog_size = strlen(name) + 1;\n  prog_name = (char *)malloc(prog_size);\n \n  if (prog_name != NULL) {\n    if (strcpy_s(prog_name, prog_size, name)) {\n      /* Handle  error */\n    }\n  } else {\n    /* Handle error */\n  }\n  /* ... */\n  free(prog_name);\n  return 0;\n}\n"}
{"id": "STR31-C_samples_c8.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c8.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (argv)\nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char * const prog_name = (argc && argv[0]) ? argv[0] : \"\";\n  /* ... */\n  return 0;\n}\n"}
{"id": "STR31-C_samples_c9.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/c9.c", "kind": "compliant", "text": "// STR31-C: Compliant Solution (getenv())\n#include <stdlib.h>\n#include <string.h>\n  \nvoid func(void) {\n  char *buff;\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    size_t len = strlen(editor) + 1;\n    buff = (char *)malloc(len);\n    if (buff == NULL) {\n      /* Handle error */\n    } \n    memcpy(buff, editor, len);\n    free(buff);\n  }\n}\n"}
{"id": "STR31-C_samples_nc0.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc0.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (Off-by-One Error)\n#include <stddef.h>\n  \nvoid copy(size_t n, char src[n], char dest[n]) {\n   size_t i;\n  \n   for (i = 0; src[i] && (i < n); ++i) {\n     dest[i] = src[i];\n   }\n   dest[i] = '\\0';\n}\n"}
{"id": "STR31-C_samples_nc1.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc1.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (gets())\n#include <stdio.h>\n  \n#define BUFFER_SIZE 1024\n \nvoid func(void) {\n  char buf[BUFFER_SIZE];\n  if (gets(buf) == NULL) {\n    /* Handle error */\n  }\n}\n"}
{"id": "STR31-C_samples_nc2.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc2.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (getchar())\n#include <stdio.h>\n  \nenum { BUFFERSIZE = 32 };\n  \nvoid func(void) {\n  char buf[BUFFERSIZE];\n  char *p;\n  int ch;\n  p = buf;\n  while ((ch = getchar()) != '\\n' && ch != EOF) {\n    *p++ = (char)ch;\n  }\n  *p++ = 0;\n  if (ch == EOF) {\n      /* Handle EOF or error */\n  }\n}\n"}
{"id": "STR31-C_samples_nc3.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc3.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (fscanf())\n#include <stdio.h>\n  \nenum { BUF_LENGTH = 1024 };\n  \nvoid get_data(void) {\n  char buf[BUF_LENGTH];\n  if (1 != fscanf(stdin, \"%s\", buf)) {\n    /* Handle error */\n  }\n \n  /* Rest of function */\n}\n"}
{"id": "STR31-C_samples_nc4.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc4.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (argv)\n#include <string.h>\n  \nint main(int argc, char *argv[]) {\n  /* Ensure argv[0] is not null */\n  const char *const name = (argc && argv[0]) ? argv[0] : \"\";\n  char prog_name[128];\n  strcpy(prog_name, name);\n  \n  return 0;\n}\n"}
{"id": "STR31-C_samples_nc5.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc5.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (getenv())\n#include <stdlib.h>\n#include <string.h>\n  \nvoid func(void) {\n  char buff[256];\n  char *editor = getenv(\"EDITOR\");\n  if (editor == NULL) {\n    /* EDITOR environment variable not set */\n  } else {\n    strcpy(buff, editor);\n  }\n}\n"}
{"id": "STR31-C_samples_nc6.c", "source": "CERT_SAMPLES", "cert_rule": "STR31-C", "file_path": "rules/str/31/nc6.c", "kind": "noncompliant", "text": "// STR31-C: Noncompliant Code Example (sprintf())\n#include <stdio.h>\n  \nvoid func(const char *name) {\n  char filename[128];\n  sprintf(filename, \"%s.txt\", name);\n}\n"}
