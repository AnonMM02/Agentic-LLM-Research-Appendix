[
  {
    "id": "CWE-362_0",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Description: The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently. Extended Description: A race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  },
  {
    "id": "CWE-362_1",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Resource Consumption (Other) When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion. Availability DoS: Crash, Exit, or Restart DoS: Instability When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash. Confidentiality Integrity Read Files or Directories Read Application Data When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59). Access Control Execute Unauthorized Code or Commands Gain Privileges or Assume Identity Bypass Protection Mechanism This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. Mitigations: Architecture and Design In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance. Architecture and Design Use thread-safe capabilities such as the data access abstraction in Spring.",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  },
  {
    "id": "CWE-362_2",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Architecture and Design Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400). Implementation When using multithreading and operating on shared variables, only use thread-safe functions. Implementation Use atomic operations on shared variables. Be wary of innocent-looking constructs such as \"x++\". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write. Implementation Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412. Implementation Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization. Implementation Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop. Implementation Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  },
  {
    "id": "CWE-362_3",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Architecture and Design Operation Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Detection Methods: Black Box Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable. White Box Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609). Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  },
  {
    "id": "CWE-362_4",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect.",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  },
  {
    "id": "CWE-362_5",
    "source": "CWE",
    "cwe_id": "CWE-362",
    "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
    "text": "Moderate Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis High Dynamic Analysis with Automated Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners SOAR Partial Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Framework-based Fuzzer Cost effective for partial coverage: Fuzz Tester Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious High Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High",
    "url": "https://cwe.mitre.org/data/definitions/362.html"
  }
]