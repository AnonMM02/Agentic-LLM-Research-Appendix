[
  {
    "id": "CWE-121_0",
    "source": "CWE",
    "cwe_id": "CWE-121",
    "title": "Stack-based Buffer Overflow",
    "text": "Description: A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function). Consequences: Availability Modify Memory DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop. Integrity Confidentiality Availability Access Control Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Integrity Confidentiality Availability Access Control Other Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service. Mitigations: Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.",
    "url": "https://cwe.mitre.org/data/definitions/121.html"
  },
  {
    "id": "CWE-121_1",
    "source": "CWE",
    "cwe_id": "CWE-121",
    "title": "Stack-based Buffer Overflow",
    "text": "D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Implementation Implement and perform bounds checking on input. Implementation Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.",
    "url": "https://cwe.mitre.org/data/definitions/121.html"
  },
  {
    "id": "CWE-121_2",
    "source": "CWE",
    "cwe_id": "CWE-121",
    "title": "Stack-based Buffer Overflow",
    "text": "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High",
    "url": "https://cwe.mitre.org/data/definitions/121.html"
  }
]