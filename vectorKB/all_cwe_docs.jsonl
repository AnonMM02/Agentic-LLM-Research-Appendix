{"id": "CWE-121_0", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "Description: A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function). Consequences: Availability Modify Memory DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop. Integrity Confidentiality Availability Access Control Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Integrity Confidentiality Availability Access Control Other Modify Memory Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service. Mitigations: Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking.", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-121_1", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Implementation Implement and perform bounds checking on input. Implementation Do not use dangerous functions such as gets. Use safer, equivalent functions which check for boundary errors. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-121_2", "source": "CWE", "cwe_id": "CWE-121", "title": "Stack-based Buffer Overflow", "text": "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/121.html"}
{"id": "CWE-122_0", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Description: A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc(). Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Buffer overflows generally lead to crashes. Other attacks leading to lack of availability are possible, including putting the program into an infinite loop. Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Modify Memory Buffer overflows often can be used to execute arbitrary code, which is usually outside the scope of a program's implicit security policy. Besides important user data, heap-based overflows can be used to overwrite function pointers that may be living in memory, pointing it to the attacker's code. Even in applications that do not explicitly use function pointers, the run-time will usually leave many in memory. For example, object methods in C++ are generally implemented using function pointers. Even in C programs, there is often a global offset table used by the underlying runtime. Integrity Confidentiality Availability Access Control Other Execute Unauthorized Code or Commands Bypass Protection Mechanism Other When the consequence is arbitrary code execution, this can often be used to subvert any other security service.", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_1", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Mitigations: Pre-design: Use a language or compiler that performs automatic bounds checking. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions. Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64].", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_2", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking. For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Implementation Implement and perform bounds checking on input. Implementation Libraries or Frameworks Do not use dangerous functions such as gets. Look for their safe equivalent, which checks for the boundary. Operation Use OS-level preventative functionality. This is not a complete solution, but it provides some defense in depth. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption.", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-122_3", "source": "CWE", "cwe_id": "CWE-122", "title": "Heap-based Buffer Overflow", "text": "Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/122.html"}
{"id": "CWE-1260_0", "source": "CWE", "cwe_id": "CWE-1260", "title": "Improper Handling of Overlap Between Protected Memory Ranges", "text": "Description: The product allows address regions to overlap, which can result in the bypassing of intended memory protection. Extended Description: Isolated memory regions and access control (read/write) policies are used by hardware to protect privileged software. Software components are often allowed to change or remap memory region definitions in order to enable flexible and dynamically changeable memory management by system software. If a software component running at lower privilege can program a memory address region to overlap with other memory regions used by software running at higher privilege, privilege escalation may be available to attackers. The memory protection unit (MPU) logic can incorrectly handle such an address overlap and allow the lower-privilege software to read or write into the protected memory region, resulting in privilege escalation attack. An address overlap weakness can also be used to launch a denial of service attack on the higher-privilege software memory regions. Consequences: Confidentiality Integrity Availability Modify Memory Read Memory DoS: Instability High Mitigations: Architecture and Design Ensure that memory regions are isolated as intended and that access control (read/write) policies are used by hardware to protect privileged software. Implementation For all of the programmable memory protection regions, the memory protection unit (MPU) design can define a priority scheme.", "url": "https://cwe.mitre.org/data/definitions/1260.html"}
{"id": "CWE-1260_1", "source": "CWE", "cwe_id": "CWE-1260", "title": "Improper Handling of Overlap Between Protected Memory Ranges", "text": "For example: if three memory regions can be programmed (Region_0, Region_1, and Region_2), the design can enforce a priority scheme, such that, if a system address is within multiple regions, then the region with the lowest ID takes priority and the access-control policy of that region will be applied. In some MPU designs, the priority scheme can also be programmed by trusted software. Hardware logic or trusted firmware can also check for region definitions and block programming of memory regions with overlapping addresses. The memory-access-control-check filter can also be designed to apply a policy filter to all of the overlapping ranges, i.e., if an address is within Region_0 and Region_1, then access to this address is only granted if both Region_0 and Region_1 policies allow the access. High Detection Methods: Manual Analysis Create a high privilege memory block of any arbitrary size. Attempt to create a lower privilege memory block with an overlap of the high privilege memory block. If the creation attempt works, fix the hardware. Repeat the test. High", "url": "https://cwe.mitre.org/data/definitions/1260.html"}
{"id": "CWE-131_0", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Description: The product does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow. Consequences: Integrity Availability Confidentiality DoS: Crash, Exit, or Restart Execute Unauthorized Code or Commands Read Memory Modify Memory If the incorrect calculation is used in the context of memory allocation, then the software may create a buffer that is smaller or larger than expected. If the allocated buffer is smaller than expected, this could lead to an out-of-bounds read or write (CWE-119), possibly causing a crash, allowing arbitrary code execution, or exposing sensitive data. Mitigations: Implementation When allocating a buffer for the purpose of transforming, converting, or encoding an input, allocate enough memory to handle the largest possible encoding. For example, in a routine that converts \"&\" characters to \"&amp;\" for HTML entity encoding, the output buffer needs to be at least 5 times as large as the input buffer. Implementation Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_1", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "[REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation. Implementation Input Validation Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server. Implementation When processing structured incoming data containing a size field followed by raw data, identify and resolve any inconsistencies between the size field and the actual size of the data (CWE-130). Implementation When allocating memory that uses sentinels to mark the end of a data structure - such as NUL bytes in strings - make sure you also include the sentinel in your calculation of the total amount of memory that must be allocated. Implementation Replace unbounded copy functions with analogous functions that support length arguments, such as strcpy with strncpy. Create these if they are not available.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_2", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Moderate This approach is still susceptible to calculation errors, including issues such as off-by-one errors (CWE-193) and incorrectly calculating buffer lengths (CWE-131). Additionally, this only addresses potential overflow issues. Resource consumption / exhaustion issues are still possible. Implementation Use sizeof() on the appropriate data type to avoid CWE-467. Implementation Use the appropriate type for the desired action. For example, in C/C++, only use unsigned types for values that could never be negative, such as height, width, or other numbers related to quantity. This will simplify validation and will reduce surprises related to unexpected casting. Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences, or buffer allocation routines that automatically track buffer size. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++). [REF-106] Operation Build and Compilation Environment Hardening Use automatic buffer overflow detection mechanisms that are offered by certain compilers or compiler extensions.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_3", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Examples include: the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice, which provide various mechanisms including canary-based detection and range/index checking. D3-SFCV (Stack Frame Canary Validation) from D3FEND [REF-1334] discusses canary-based detection in detail. Defense in Depth This is not necessarily a complete solution, since these mechanisms only detect certain types of overflows. In addition, the result is still a denial of service, since the typical response is to exit the application. Operation Build and Compilation Environment Hardening Run or compile the software using features or extensions that randomly arrange the positions of a program's executable and libraries in memory. Because this makes the addresses unpredictable, it can prevent an attacker from reliably jumping to exploitable code. Examples include Address Space Layout Randomization (ASLR) [REF-58] [REF-60] and Position-Independent Executables (PIE) [REF-64]. Imported modules may be similarly realigned if their default memory addresses conflict with other modules, in a process known as \"rebasing\" (for Windows) and \"prelinking\" (for Linux) [REF-1332] using randomly generated addresses. ASLR for libraries cannot be used in conjunction with prelink since it would require relocating the libraries at run-time, defeating the whole purpose of prelinking.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_4", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "For more information on these techniques see D3-SAOR (Segment Address Offset Randomization) from D3FEND [REF-1335]. Defense in Depth These techniques do not provide a complete solution. For instance, exploits frequently use a bug that discloses memory addresses in order to maximize reliability of code execution [REF-1337]. It has also been shown that a side-channel attack can bypass ASLR [REF-1333] Operation Environment Hardening Use a CPU and operating system that offers Data Execution Protection (using hardware NX or XD bits) or the equivalent techniques that simulate this feature in software, such as PaX [REF-60] [REF-61]. These techniques ensure that any instruction executed is exclusively at a memory address that is part of the code segment. For more information on these techniques see D3-PSEP (Process Segment Execution Prevention) from D3FEND [REF-1336]. Defense in Depth This is not a complete solution, since buffer overflows could be used to overwrite nearby variables to modify the software's state in dangerous ways. In addition, it cannot be used in cases in which self-modifying code is required. Finally, an attack could still cause a denial of service, since the typical response is to exit the application. Implementation Compilation or Build Hardening Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_5", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system. Architecture and Design Operation Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Architecture and Design Operation Sandbox or Jail Run the code in a \"jail\" or similar sandbox environment that enforces strict boundaries between the process and the operating system. This may effectively restrict which files can be accessed in a particular directory or which commands can be executed by the software. OS-level examples include the Unix chroot jail, AppArmor, and SELinux. In general, managed code may provide some protection. For example, java.io.FilePermission in the Java SecurityManager allows the software to specify restrictions on file operations. This may not be a feasible solution, and it only limits the impact to the operating system; the rest of the application may still be subject to compromise. Be careful to avoid CWE-243 and other weaknesses related to jails.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_6", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Limited The effectiveness of this mitigation depends on the prevention capabilities of the specific sandbox or jail being used and might only help to reduce the scope of an attack, such as restricting the attacker to certain system calls or limiting the portion of the file system that can be accessed. Detection Methods: Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. Automated static analysis generally does not account for environmental considerations when reporting potential errors in buffer calculations. This can make it difficult for users to determine which warnings should be investigated first. For example, an analysis tool might report buffer overflows that originate from command line arguments in a program that is not expected to run with setuid or other special privileges. High Detection techniques for buffer-related errors are more mature than for most other weakness types. Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_7", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Moderate Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem. Manual Analysis Manual analysis can be useful for finding this weakness, but it might not achieve desired code coverage within limited time constraints. This becomes difficult for weaknesses that must be considered for all inputs, since the attack surface can be too large. Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations. This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program. High These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-131_8", "source": "CWE", "cwe_id": "CWE-131", "title": "Incorrect Calculation of Buffer Size", "text": "Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis High Manual Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Binary / Bytecode disassembler - then use manual analysis for vulnerabilities & anomalies SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source Manual Source Code Review (not inspections) SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer Cost effective for partial coverage: Source Code Quality Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/131.html"}
{"id": "CWE-1335_0", "source": "CWE", "cwe_id": "CWE-1335", "title": "Incorrect Bitwise Shift of Integer", "text": "Description: An integer value is specified to be shifted by a negative amount or an amount greater than or equal to the number of bits contained in the value causing an unexpected or indeterminate result. Extended Description: Specifying a value to be shifted by a negative amount is undefined in various languages. Various computer architectures implement this action in different ways. The compilers and interpreters when generating code to accomplish a shift generally do not do a check for this issue. Specifying an over-shift, a shift greater than or equal to the number of bits contained in a value to be shifted, produces a result which varies by architecture and compiler. In some languages, this action is specifically listed as producing an undefined result. Consequences: Integrity DoS: Crash, Exit, or Restart Mitigations: Implementation Implicitly or explicitly add checks and mitigation for negative or over-shift values.", "url": "https://cwe.mitre.org/data/definitions/1335.html"}
{"id": "CWE-190_0", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Description: The product performs a calculation that can produce an integer overflow or wraparound when the logic assumes that the resulting value will always be larger than the original value. This occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may become a very small or negative number. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (Memory) DoS: Instability This weakness can generally lead to undefined behavior and therefore crashes. When the calculated result is used for resource allocation, this weakness can cause too many (or too few) resources to be allocated, possibly enabling crashes if the product requests more resources than can be provided. Integrity Modify Memory If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the overflow/wraparound results in other conditions such as buffer overflows, further memory corruption may occur. Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism This weakness can sometimes trigger buffer overflows, which can be used to execute arbitrary code. This is usually outside the scope of the product's implicit security policy.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_1", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Availability Other Alter Execution Logic DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) If the overflow/wraparound occurs in a loop index variable, this could cause the loop to terminate at the wrong time - too early, too late, or not at all (i.e., infinite loops). With too many iterations, some loops could consume too many resources such as memory, file handles, etc., possibly leading to a crash or other DoS. Access Control Bypass Protection Mechanism If integer values are used in security-critical decisions, such as calculating quotas or allocation limits, integer overflows can be used to cause an incorrect security decision. Mitigations: Requirements Ensure that all protocols are strictly defined, such that all out-of-bounds behavior can be identified simply, and require strict conformance to the protocol. Requirements Language Selection Use a language that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. If possible, choose a language or compiler that performs automatic bounds checking. Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid [REF-1482]. Use libraries or frameworks that make it easier to handle numbers without unexpected consequences. Examples include safe integer handling packages such as SafeInt (C++) or IntegerLib (C or C++).", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_2", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "[REF-106] Implementation Input Validation Perform input validation on any numeric input by ensuring that it is within the expected range. Enforce that the input meets both the minimum and maximum requirements for the expected range. Use unsigned integers where possible. This makes it easier to perform validation for integer overflows. When signed integers are required, ensure that the range check includes minimum values as well as maximum values. Implementation Understand the programming language's underlying representation and how it interacts with numeric calculation (CWE-681). Pay close attention to byte size discrepancies, precision, signed/unsigned distinctions, truncation, conversion and casting between types, \"not-a-number\" calculations, and how the language handles numbers that are too large or too small for its underlying representation. [REF-7] Also be careful to account for 32-bit, 64-bit, and other potential differences that may affect the numeric representation. Architecture and Design For any security checks that are performed on the client side, ensure that these checks are duplicated on the server side, in order to avoid CWE-602. Attackers can bypass the client-side checks by modifying values after the checks have been performed, or by changing the client to remove the client-side checks entirely. Then, these modified values would be submitted to the server.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_3", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Implementation Compilation or Build Hardening Examine compiler warnings closely and eliminate problems with potential security implications, such as signed / unsigned mismatch in memory operations, or use of uninitialized variables. Even if the weakness is rarely exploitable, a single failure may lead to the compromise of the entire system. Detection Methods: Automated Static Analysis This weakness can often be detected using automated static analysis tools. Many modern tools use data flow analysis or constraint-based techniques to minimize the number of false positives. High Black Box Sometimes, evidence of this weakness can be detected using dynamic tools and techniques that interact with the product using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The product's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Moderate Without visibility into the code, black box methods may not be able to sufficiently distinguish this weakness from others, requiring follow-up manual methods to diagnose the underlying problem. Manual Analysis This weakness can be detected using tools and techniques that require manual (human) analysis, such as penetration testing, threat modeling, and interactive tools that allow the tester to record and modify an active session. Specifically, manual static analysis is useful for evaluating the correctness of allocation calculations.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_4", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "This can be useful for detecting overflow conditions (CWE-190) or similar weaknesses that might have serious security impacts on the program. High These may be more effective than strictly automated techniques. This is especially the case with weaknesses that are related to design and business rules.", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-190_5", "source": "CWE", "cwe_id": "CWE-190", "title": "Integer Overflow or Wraparound", "text": "Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Binary Weakness Analysis - including disassembler + source code weakness analysis High Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Fuzz Tester Framework-based Fuzzer SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Manual Source Code Review (not inspections) SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/190.html"}
{"id": "CWE-191_0", "source": "CWE", "cwe_id": "CWE-191", "title": "Integer Underflow (Wrap or Wraparound)", "text": "Description: The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result. Extended Description: This can happen in signed and unsigned cases. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Instability This weakness will generally lead to undefined behavior and therefore crashes. In the case of overflows involving loop index variables, the likelihood of infinite loops is also high. Integrity Modify Memory If the value in question is important to data (as opposed to flow), simple data corruption has occurred. Also, if the wrap around results in other conditions such as buffer overflows, further memory corruption may occur. Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism This weakness can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/191.html"}
{"id": "CWE-191_1", "source": "CWE", "cwe_id": "CWE-191", "title": "Integer Underflow (Wrap or Wraparound)", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/191.html"}
{"id": "CWE-196_0", "source": "CWE", "cwe_id": "CWE-196", "title": "Unsigned to Signed Conversion Error", "text": "Description: The product uses an unsigned primitive and performs a cast to a signed primitive, which can produce an unexpected value if the value of the unsigned primitive can not be represented using a signed primitive. Extended Description: Although less frequent an issue than signed-to-unsigned conversion, unsigned-to-signed conversion can be the perfect precursor to dangerous buffer underwrite conditions that allow attackers to move down the stack where they otherwise might not have access in a normal buffer overflow condition. Buffer underwrites occur frequently when large unsigned values are cast to signed values, and then used as indexes into a buffer or for pointer arithmetic. Consequences: Availability DoS: Crash, Exit, or Restart Incorrect sign conversions generally lead to undefined behavior, and therefore crashes. Integrity Modify Memory If a poor cast lead to a buffer overflow or similar condition, data integrity may be affected. Integrity Confidentiality Availability Access Control Execute Unauthorized Code or Commands Bypass Protection Mechanism Improper signed-to-unsigned conversions without proper checking can sometimes trigger buffer overflows which can be used to execute arbitrary code. This is usually outside the scope of a program's implicit security policy. Mitigations: Requirements Choose a language which is not subject to these casting flaws. Architecture and Design Design object accessor functions to implicitly check values for valid sizes.", "url": "https://cwe.mitre.org/data/definitions/196.html"}
{"id": "CWE-196_1", "source": "CWE", "cwe_id": "CWE-196", "title": "Unsigned to Signed Conversion Error", "text": "Ensure that all functions which will be used as a size are checked previous to use as a size. If the language permits, throw exceptions rather than using in-band errors. Implementation Error check the return values of all functions. Be aware of implicit casts made, and use unsigned variables for sizes if at all possible.", "url": "https://cwe.mitre.org/data/definitions/196.html"}
{"id": "CWE-252_0", "source": "CWE", "cwe_id": "CWE-252", "title": "Unchecked Return Value", "text": "Description: The product does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions. Extended Description: Two common programmer assumptions are \"this function call can never fail\" and \"it doesn't matter if this function call fails\". If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the product is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges. Consequences: Availability Integrity Unexpected State DoS: Crash, Exit, or Restart An unexpected return value could place the system in a state that could lead to a crash or other unintended behaviors. Mitigations: Implementation Check the results of all functions that return a value and verify that the value is expected. High Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. Implementation For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use.", "url": "https://cwe.mitre.org/data/definitions/252.html"}
{"id": "CWE-252_1", "source": "CWE", "cwe_id": "CWE-252", "title": "Unchecked Return Value", "text": "When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished [REF-1484]. Implementation Ensure that you account for all possible return values from the function. Implementation When designing a function, make sure you return a value or throw an exception in case of an error. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/252.html"}
{"id": "CWE-362_0", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Description: The product contains a concurrent code sequence that requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence operating concurrently. Extended Description: A race condition occurs within concurrent environments, and it is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc. A race condition violates these properties, which are closely related: Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution. Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an \"interfering code sequence\" can still access the shared resource, violating exclusivity. The interfering code sequence could be \"trusted\" or \"untrusted.\" A trusted interfering code sequence occurs within the product; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable product.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_1", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Resource Consumption (Other) When a race condition makes it possible to bypass a resource cleanup routine or trigger multiple initialization routines, it may lead to resource exhaustion. Availability DoS: Crash, Exit, or Restart DoS: Instability When a race condition allows multiple control flows to access a resource simultaneously, it might lead the product(s) into unexpected states, possibly resulting in a crash. Confidentiality Integrity Read Files or Directories Read Application Data When a race condition is combined with predictable resource names and loose permissions, it may be possible for an attacker to overwrite or access confidential data (CWE-59). Access Control Execute Unauthorized Code or Commands Gain Privileges or Assume Identity Bypass Protection Mechanism This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider. Mitigations: Architecture and Design In languages that support it, use synchronization primitives. Only wrap these around critical code to minimize the impact on performance. Architecture and Design Use thread-safe capabilities such as the data access abstraction in Spring.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_2", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Architecture and Design Minimize the usage of shared resources in order to remove as much complexity as possible from the control flow and to reduce the likelihood of unexpected conditions occurring. Additionally, this will minimize the amount of synchronization necessary and may even help to reduce the likelihood of a denial of service where an attacker may be able to repeatedly trigger a critical section (CWE-400). Implementation When using multithreading and operating on shared variables, only use thread-safe functions. Implementation Use atomic operations on shared variables. Be wary of innocent-looking constructs such as \"x++\". This may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read, followed by a computation, followed by a write. Implementation Use a mutex if available, but be sure to avoid related weaknesses such as CWE-412. Implementation Avoid double-checked locking (CWE-609) and other implementation errors that arise when trying to avoid the overhead of synchronization. Implementation Disable interrupts or signals over critical parts of the code, but also make sure that the code does not go into a large or infinite loop. Implementation Use the volatile type modifier for critical variables to avoid unexpected compiler optimization or reordering. This does not necessarily solve the synchronization problem, but it can help.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_3", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Architecture and Design Operation Environment Hardening Run your code using the lowest privileges that are required to accomplish the necessary tasks [REF-76]. If possible, create isolated accounts with limited privileges that are only used for a single task. That way, a successful attack will not immediately give the attacker access to the rest of the software or its environment. For example, database applications rarely need to run as the database administrator, especially in day-to-day operations. Detection Methods: Black Box Black box methods may be able to identify evidence of race conditions via methods such as multiple simultaneous connections, which may cause the software to become instable or crash. However, race conditions with very narrow timing windows would not be detectable. White Box Common idioms are detectable in white box analysis, such as time-of-check-time-of-use (TOCTOU) file operations (CWE-367), or double-checked locking (CWE-609). Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_4", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Race conditions may be detected with a stress-test by calling the software simultaneously from a large number of threads or processes, and look for evidence of any unexpected behavior. Insert breakpoints or delays in between relevant code statements to artificially expand the race window so that it will be easier to detect.", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-362_5", "source": "CWE", "cwe_id": "CWE-362", "title": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')", "text": "Moderate Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Bytecode Weakness Analysis - including disassembler + source code weakness analysis Cost effective for partial coverage: Binary Weakness Analysis - including disassembler + source code weakness analysis High Dynamic Analysis with Automated Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners SOAR Partial Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Framework-based Fuzzer Cost effective for partial coverage: Fuzz Tester Monitored Virtual Environment - run potentially malicious code in sandbox / wrapper / virtual machine, see if it does anything suspicious High Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Formal Methods / Correct-By-Construction Cost effective for partial coverage: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) High", "url": "https://cwe.mitre.org/data/definitions/362.html"}
{"id": "CWE-369_0", "source": "CWE", "cwe_id": "CWE-369", "title": "Divide By Zero", "text": "Description: The product divides a value by zero. Extended Description: This weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height. Consequences: Availability DoS: Crash, Exit, or Restart A Divide by Zero results in a crash. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/369.html"}
{"id": "CWE-393_0", "source": "CWE", "cwe_id": "CWE-393", "title": "Return of Wrong Status Code", "text": "Description: A function or operation returns an incorrect return value or status code that does not indicate the true result of execution, causing the product to modify its behavior based on the incorrect result. Extended Description: This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the product to assume that an action is safe or correct, even when it is not. Consequences: Integrity Other Unexpected State Alter Execution Logic This weakness could place the system in a state that could lead unexpected logic to be executed or other unintended behaviors. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/393.html"}
{"id": "CWE-401_0", "source": "CWE", "cwe_id": "CWE-401", "title": "Missing Release of Memory after Effective Lifetime", "text": "Description: The product does not sufficiently track and release allocated memory after it has been used, making the memory unavailable for reallocation and reuse. Consequences: Availability DoS: Crash, Exit, or Restart DoS: Instability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) Most memory leaks result in general product reliability problems, but if an attacker can intentionally trigger a memory leak, the attacker might be able to launch a denial of service attack (by crashing or hanging the program) or take advantage of other unexpected program behavior resulting from a low memory condition. Other Reduce Performance Mitigations: Implementation Libraries or Frameworks Choose a language or tool that provides automatic memory management, or makes manual memory management less error-prone. For example, glibc in Linux provides protection against free of invalid pointers. When using Xcode to target OS X or iOS, enable automatic reference counting (ARC) [REF-391]. To help correctly and consistently manage memory when programming in C++, consider using a smart pointer class such as std::auto_ptr (defined by ISO/IEC ISO/IEC 14882:2003), std::shared_ptr and std::unique_ptr (specified by an upcoming revision of the C++ standard, informally referred to as C++ 1x), or equivalent solutions such as Boost. Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution.", "url": "https://cwe.mitre.org/data/definitions/401.html"}
{"id": "CWE-401_1", "source": "CWE", "cwe_id": "CWE-401", "title": "Missing Release of Memory after Effective Lifetime", "text": "Architecture and Design Build and Compilation The Boehm-Demers-Weiser Garbage Collector or valgrind can be used to detect leaks in code. This is not a complete solution as it is not 100% effective. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/401.html"}
{"id": "CWE-415_0", "source": "CWE", "cwe_id": "CWE-415", "title": "Double Free", "text": "Description: The product calls free() twice on the same memory address. Consequences: Integrity Confidentiality Availability Modify Memory Execute Unauthorized Code or Commands When a program calls free() twice with the same argument, the program's memory management data structures may become corrupted, potentially leading to the reading or modification of unexpected memory addresses. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack. Doubly freeing memory may result in a write-what-where condition, allowing an attacker to execute arbitrary code. Mitigations: Architecture and Design Choose a language that provides automatic memory management. Implementation Ensure that each allocation is freed only once. After freeing a chunk, set the pointer to NULL to ensure the pointer cannot be freed again. In complicated error conditions, be sure that clean-up routines respect the state of allocation properly. If the language is object oriented, ensure that object destructors delete each chunk of memory only once. Implementation Use a static analysis tool to find double free instances.", "url": "https://cwe.mitre.org/data/definitions/415.html"}
{"id": "CWE-415_1", "source": "CWE", "cwe_id": "CWE-415", "title": "Double Free", "text": "Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/415.html"}
{"id": "CWE-416_0", "source": "CWE", "cwe_id": "CWE-416", "title": "Use After Free", "text": "Description: The product reuses or references memory after it has been freed. At some point afterward, the memory may be allocated again and saved in another pointer, while the original pointer references a location somewhere within the new allocation. Any operations using the original pointer are no longer valid because the memory \"belongs\" to the code that operates on the new pointer. Consequences: Integrity Modify Memory The use of previously freed memory may corrupt valid data, if the memory area in question has been allocated and used properly elsewhere. Availability DoS: Crash, Exit, or Restart If chunk consolidation occurs after the use of previously freed data, the process may crash when invalid data is used as chunk information. Integrity Confidentiality Availability Execute Unauthorized Code or Commands If malicious data is entered before chunk consolidation can take place, it may be possible to take advantage of a write-what-where primitive to execute arbitrary code. If the newly allocated data happens to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved. Mitigations: Architecture and Design Language Selection Choose a language that provides automatic memory management. Implementation Attack Surface Reduction When freeing pointers, be sure to set them to NULL once they are freed.", "url": "https://cwe.mitre.org/data/definitions/416.html"}
{"id": "CWE-416_1", "source": "CWE", "cwe_id": "CWE-416", "title": "Use After Free", "text": "However, the utilization of multiple or complex data structures may lower the usefulness of this strategy. Defense in Depth If a bug causes an attempted access of this pointer, then a NULL dereference could still lead to a crash or other unexpected behavior, but it will reduce or eliminate the risk of code execution. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/416.html"}
{"id": "CWE-457_0", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Description: The code uses a variable that has not been initialized, leading to unpredictable or unintended results. Extended Description: In some languages such as C and C++, stack variables are not initialized by default. They generally contain junk data with the contents of stack memory before the function was invoked. An attacker can sometimes control or read these contents. In other languages or conditions, a variable that is not explicitly initialized can be given a default value that has security implications, depending on the logic of the program. The presence of an uninitialized variable can sometimes indicate a typographic error in the code. Consequences: Availability Integrity Other Other Initial variables usually contain junk, which can not be trusted for consistency. This can lead to denial of service conditions, or modify control flow in unexpected ways. In some cases, an attacker can \"pre-initialize\" the variable using previous actions, which might enable code execution. This can cause a race condition if a lock variable check passes when it should not. Authorization Other Other Strings that are not initialized are especially dangerous, since many functions expect a null at the end -- and only at the end -- of a string. Mitigations: Implementation Attack Surface Reduction Ensure that critical variables are initialized before first use [REF-1485].", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-457_1", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Build and Compilation Compilation or Build Hardening Most compilers will complain about the use of uninitialized variables if warnings are turned on. Implementation Operation When using a language that does not require explicit declaration of variables, run or compile the software in a mode that reports undeclared or unknown variables. This may indicate the presence of a typographic error in the variable's name. Requirements Language Selection Choose a language that is not susceptible to these issues. Architecture and Design Mitigating technologies such as safe string libraries and container abstractions could be introduced. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-457_2", "source": "CWE", "cwe_id": "CWE-457", "title": "Use of Uninitialized Variable", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/457.html"}
{"id": "CWE-463_0", "source": "CWE", "cwe_id": "CWE-463", "title": "Deletion of Data Structure Sentinel", "text": "Description: The accidental deletion of a data-structure sentinel can cause serious programming logic problems. Extended Description: Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety. Consequences: Availability Other Other Generally this error will cause the data structure to not work properly. Authorization Other Other If a control character, such as NULL is removed, one may cause resource access control problems. Mitigations: Architecture and Design Use an abstraction library to abstract away risky APIs. Not a complete solution. Build and Compilation Compilation or Build Hardening Run or compile the software using features or extensions that automatically provide a protection mechanism that mitigates or eliminates buffer overflows. For example, certain compilers and extensions provide automatic buffer overflow detection mechanisms that are built into the compiled code. Examples include the Microsoft Visual Studio /GS flag, Fedora/Red Hat FORTIFY_SOURCE GCC flag, StackGuard, and ProPolice.", "url": "https://cwe.mitre.org/data/definitions/463.html"}
{"id": "CWE-463_1", "source": "CWE", "cwe_id": "CWE-463", "title": "Deletion of Data Structure Sentinel", "text": "Defense in Depth This is not necessarily a complete solution, since these mechanisms can only detect certain types of overflows. In addition, an attack could still cause a denial of service, since the typical response is to exit the application. Operation Use OS-level preventative functionality. Not a complete solution.", "url": "https://cwe.mitre.org/data/definitions/463.html"}
{"id": "CWE-469_0", "source": "CWE", "cwe_id": "CWE-469", "title": "Use of Pointer Subtraction to Determine Size", "text": "Description: The product subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk. Consequences: Access Control Integrity Confidentiality Availability Modify Memory Read Memory Execute Unauthorized Code or Commands Gain Privileges or Assume Identity There is the potential for arbitrary code execution with privileges of the vulnerable program. Mitigations: Implementation Save an index variable. This is the recommended solution. Rather than subtract pointers from one another, use an index variable of the same size as the pointers in question. Use this variable to \"walk\" from one pointer to the other and calculate the difference. Always validate this number. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it.", "url": "https://cwe.mitre.org/data/definitions/469.html"}
{"id": "CWE-469_1", "source": "CWE", "cwe_id": "CWE-469", "title": "Use of Pointer Subtraction to Determine Size", "text": "Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/469.html"}
{"id": "CWE-476_0", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Description: The product dereferences a pointer that it expects to be valid but is NULL. Consequences: Availability DoS: Crash, Exit, or Restart NULL pointer dereferences usually result in the failure of the process unless exception handling (on some platforms) is available and implemented. Even when exception handling is being used, it can still be very difficult to return the software to a safe state of operation. Integrity Confidentiality Execute Unauthorized Code or Commands Read Memory Modify Memory In rare circumstances, when NULL is equivalent to the 0x0 memory address and privileged code can access it, then writing or reading memory is possible, which may lead to code execution. Mitigations: Implementation For any pointers that could have been modified or provided from a function that can return NULL, check the pointer for NULL before use. When working with a multithreaded or otherwise asynchronous environment, ensure that proper locking APIs are used to lock before the check, and unlock when it has finished [REF-1484]. Requirements Select a programming language that is not susceptible to these issues. Implementation Check the results of all functions that return a value and verify that the value is non-null before acting upon it. Moderate Checking the return value of the function will typically be sufficient, however beware of race conditions (CWE-362) in a concurrent environment. This solution does not handle the use of improperly initialized variables (CWE-665).", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-476_1", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Architecture and Design Identify all variables and data stores that receive information from external sources, and apply input validation to make sure that they are only initialized to expected values. Implementation Explicitly initialize all variables and other data stores, either during declaration or just before the first usage. Detection Methods: Automated Dynamic Analysis This weakness can be detected using dynamic tools and techniques that interact with the software using large test suites with many diverse inputs, such as fuzz testing (fuzzing), robustness testing, and fault injection. The software's operation may slow down, but it should not become unstable, crash, or generate incorrect results. Moderate Manual Dynamic Analysis Identify error conditions that are not likely to occur during normal usage and trigger them. For example, run the program under low memory conditions, run with insufficient privileges or permissions, interrupt a transaction before it is completed, or disable connectivity to basic network services such as DNS. Monitor the software for any unexpected behavior. If you trigger an unhandled exception or similar error that was discovered and handled by the application's environment, it may still indicate unexpected conditions that were not handled by the application itself.", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-476_2", "source": "CWE", "cwe_id": "CWE-476", "title": "NULL Pointer Dereference", "text": "Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/476.html"}
{"id": "CWE-480_0", "source": "CWE", "cwe_id": "CWE-480", "title": "Use of Incorrect Operator", "text": "Description: The product accidentally uses the wrong operator, which changes the logic in security-relevant ways. Extended Description: These types of errors are generally the result of a typo by the programmer. Consequences: Other Alter Execution Logic This weakness can cause unintended logic to be executed and other unexpected application behavior. Detection Methods: Automated Static Analysis This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program. Manual Static Analysis This weakness can be found easily using static analysis. However in some cases an operator might appear to be incorrect, but is actually correct and reflects unusual logic within the program.", "url": "https://cwe.mitre.org/data/definitions/480.html"}
{"id": "CWE-484_0", "source": "CWE", "cwe_id": "CWE-484", "title": "Omitted Break Statement in Switch", "text": "Description: The product omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition. Extended Description: This can lead to critical code executing in situations where it should not. Consequences: Other Alter Execution Logic This weakness can cause unintended logic to be executed and other unexpected application behavior. Mitigations: Implementation Omitting a break statement so that one may fall through is often indistinguishable from an error, and therefore should be avoided. If you need to use fall-through capabilities, make sure that you have clearly documented this within the switch statement, and ensure that you have examined all the logical possibilities. Implementation The functionality of omitting a break statement could be clarified with an if statement. This method is much safer. Detection Methods: White Box Omission of a break statement might be intentional, in order to support fallthrough. Automated detection methods might therefore be erroneous. Semantic understanding of expected product behavior is required to interpret whether the code is correct. Black Box Since this weakness is associated with a code construct, it would be indistinguishable from other errors that produce the same behavior.", "url": "https://cwe.mitre.org/data/definitions/484.html"}
{"id": "CWE-484_1", "source": "CWE", "cwe_id": "CWE-484", "title": "Omitted Break Statement in Switch", "text": "Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/484.html"}
{"id": "CWE-561_0", "source": "CWE", "cwe_id": "CWE-561", "title": "Dead Code", "text": "Description: The product contains dead code, which can never be executed. Extended Description: Dead code is code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed. Consequences: Other Quality Degradation Dead code that results from code that can never be executed is an indication of problems with the source code that needs to be fixed and is an indication of poor quality. Other Reduce Maintainability Mitigations: Implementation Remove dead code before deploying the application. Testing Use a static analysis tool to spot dead code.", "url": "https://cwe.mitre.org/data/definitions/561.html"}
{"id": "CWE-561_1", "source": "CWE", "cwe_id": "CWE-561", "title": "Dead Code", "text": "Detection Methods: Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction Cost effective for partial coverage: Attack Modeling High Automated Static Analysis - Binary or Bytecode According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Binary / Bytecode Quality Analysis Compare binary / bytecode to application permission manifest High Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Automated Monitored Execution SOAR Partial Automated Static Analysis According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Permission Manifest Analysis SOAR Partial Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Source Code Quality Analyzer Cost effective for partial coverage: Warning Flags Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer High Dynamic Analysis with Automated Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Web Application Scanner Web Services Scanner Database Scanners SOAR Partial Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High", "url": "https://cwe.mitre.org/data/definitions/561.html"}
{"id": "CWE-562_0", "source": "CWE", "cwe_id": "CWE-562", "title": "Return of Stack Variable Address", "text": "Description: A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash. Extended Description: Because local variables are allocated on the stack, when a program returns a pointer to a local variable, it is returning a stack address. A subsequent function call is likely to re-use this same stack address, thereby overwriting the value of the pointer, which no longer corresponds to the same variable since a function's stack frame is invalidated when it returns. At best this will cause the value of the pointer to change unexpectedly. In many cases it causes the program to crash the next time the pointer is dereferenced. Consequences: Availability Integrity Confidentiality Read Memory Modify Memory Execute Unauthorized Code or Commands DoS: Crash, Exit, or Restart If the returned stack buffer address is dereferenced after the return, then an attacker may be able to modify or read memory, depending on how the address is used. If the address is used for reading, then the address itself may be exposed, or the contents that the address points to. If the address is used for writing, this can lead to a crash and possibly code execution. Mitigations: Testing Use static analysis tools to spot return of the address of a stack variable.", "url": "https://cwe.mitre.org/data/definitions/562.html"}
{"id": "CWE-562_1", "source": "CWE", "cwe_id": "CWE-562", "title": "Return of Stack Variable Address", "text": "Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/562.html"}
{"id": "CWE-563_0", "source": "CWE", "cwe_id": "CWE-563", "title": "Assignment to Variable without Use", "text": "Description: The variable's value is assigned but never used, making it a dead store. Extended Description: After the assignment, the variable is either assigned another value or goes out of scope. It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug. Consequences: Other Quality Degradation Varies by Context This weakness could be an indication of a bug in the program or a deprecated variable that was not removed and is an indication of poor quality. This could lead to further bugs and the introduction of weaknesses. Mitigations: Implementation Remove unused variables from the code. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/563.html"}
{"id": "CWE-570_0", "source": "CWE", "cwe_id": "CWE-570", "title": "Expression is Always False", "text": "Description: The product contains an expression that will always evaluate to false. Consequences: Other Quality Degradation Varies by Context Mitigations: Testing Use Static Analysis tools to spot such conditions. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/570.html"}
{"id": "CWE-571_0", "source": "CWE", "cwe_id": "CWE-571", "title": "Expression is Always True", "text": "Description: The product contains an expression that will always evaluate to true. Consequences: Other Quality Degradation Varies by Context Mitigations: Testing Use Static Analysis tools to spot such conditions. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/571.html"}
{"id": "CWE-590_0", "source": "CWE", "cwe_id": "CWE-590", "title": "Free of Memory not on the Heap", "text": "Description: The product calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc(). Extended Description: When free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code. Consequences: Integrity Confidentiality Availability Execute Unauthorized Code or Commands Modify Memory There is the potential for arbitrary code execution with privileges of the vulnerable program via a \"write, what where\" primitive. If pointers to memory which hold user information are freed, a malicious user will be able to write 4 bytes anywhere in memory. Mitigations: Implementation Only free pointers that you have called malloc on previously. This is the recommended solution. Keep track of which pointers point at the beginning of valid chunks and free them only once. Implementation Before freeing a pointer, the programmer should make sure that the pointer was previously allocated on the heap and that the memory belongs to the programmer. Freeing an unallocated pointer will cause undefined behavior in the program.", "url": "https://cwe.mitre.org/data/definitions/590.html"}
{"id": "CWE-590_1", "source": "CWE", "cwe_id": "CWE-590", "title": "Free of Memory not on the Heap", "text": "Architecture and Design Libraries or Frameworks Use a vetted library or framework that does not allow this weakness to occur or provides constructs that make this weakness easier to avoid. For example, glibc in Linux provides protection against free of invalid pointers. Architecture and Design Use a language that provides abstractions for memory allocation and deallocation. Testing Use a tool that dynamically detects memory management problems, such as valgrind. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs. Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/590.html"}
{"id": "CWE-628_0", "source": "CWE", "cwe_id": "CWE-628", "title": "Function Call with Incorrectly Specified Arguments", "text": "Description: The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to always-incorrect behavior and resultant weaknesses. Extended Description: There are multiple ways in which this weakness can be introduced, including: the wrong variable or reference; an incorrect number of arguments; incorrect order of arguments; wrong type of arguments; or wrong value. Consequences: Other Access Control Quality Degradation Gain Privileges or Assume Identity This weakness can cause unintended behavior and can lead to additional weaknesses such as allowing an attacker to gain unintended access to system resources. Mitigations: Build and Compilation Once found, these issues are easy to fix. Use code inspection tools and relevant compiler features to identify potential violations. Pay special attention to code that is not likely to be exercised heavily during QA. Architecture and Design Make sure your API's are stable before you use them in production code. Detection Methods: Other Since these bugs typically introduce incorrect behavior that is obvious to users, they are found quickly, unless they occur in rarely-tested code paths. Managing the correct number of arguments can be made more difficult in cases where format strings are used, or when variable numbers of arguments are supported.", "url": "https://cwe.mitre.org/data/definitions/628.html"}
{"id": "CWE-667_0", "source": "CWE", "cwe_id": "CWE-667", "title": "Improper Locking", "text": "Description: The product does not properly acquire or release a lock on a resource, leading to unexpected resource state changes and behaviors. Extended Description: Locking is a type of synchronization behavior that ensures that multiple independently-operating processes or threads do not interfere with each other when accessing the same resource. All processes/threads are expected to follow the same steps for locking. If these steps are not followed precisely - or if no locking is done at all - then another process/thread could modify the shared resource in a way that is not visible or predictable to the original process. This can lead to data or memory corruption, denial of service, etc. Consequences: Availability DoS: Resource Consumption (CPU) Inconsistent locking discipline can lead to deadlock. Mitigations: Implementation Libraries or Frameworks Use industry standard APIs to implement locking mechanism. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/667.html"}
{"id": "CWE-675_0", "source": "CWE", "cwe_id": "CWE-675", "title": "Multiple Operations on Resource in Single-Operation Context", "text": "Description: The product performs the same operation on a resource two or more times, when the operation should only be applied once. Consequences: Other Other", "url": "https://cwe.mitre.org/data/definitions/675.html"}
{"id": "CWE-681_0", "source": "CWE", "cwe_id": "CWE-681", "title": "Incorrect Conversion between Numeric Types", "text": "Description: When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur. Consequences: Other Integrity Unexpected State Quality Degradation The program could wind up using the wrong number and generate incorrect results. If the number is used to allocate resources or make a security decision, then this could introduce a vulnerability. Mitigations: Implementation Avoid making conversion between numeric types. Always check for the allowed ranges.", "url": "https://cwe.mitre.org/data/definitions/681.html"}
{"id": "CWE-703_0", "source": "CWE", "cwe_id": "CWE-703", "title": "Improper Check or Handling of Exceptional Conditions", "text": "Description: The product does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the product. Consequences: Confidentiality Availability Integrity Read Application Data DoS: Crash, Exit, or Restart Unexpected State Detection Methods: Dynamic Analysis with Manual Results Interpretation According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Fault Injection - source code Fault Injection - binary Cost effective for partial coverage: Forced Path Execution High Manual Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Manual Source Code Review (not inspections) Cost effective for partial coverage: Focused Manual Spotcheck - Focused manual analysis of source High Automated Static Analysis - Source Code According to SOAR [REF-1479], the following detection techniques may be useful: Cost effective for partial coverage: Source code Weakness Analyzer Context-configured Source Code Weakness Analyzer SOAR Partial Architecture or Design Review According to SOAR [REF-1479], the following detection techniques may be useful: Highly cost effective: Inspection (IEEE 1028 standard) (can apply to requirements, design, source code, etc.) Formal Methods / Correct-By-Construction High", "url": "https://cwe.mitre.org/data/definitions/703.html"}
{"id": "CWE-764_0", "source": "CWE", "cwe_id": "CWE-764", "title": "Multiple Locks of a Critical Resource", "text": "Description: The product locks a critical resource more times than intended, leading to an unexpected state in the system. Extended Description: When a product is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE-412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible. Consequences: Availability Integrity DoS: Resource Consumption (CPU) DoS: Crash, Exit, or Restart Unexpected State Mitigations: Implementation When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the software acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.", "url": "https://cwe.mitre.org/data/definitions/764.html"}
{"id": "CWE-765_0", "source": "CWE", "cwe_id": "CWE-765", "title": "Multiple Unlocks of a Critical Resource", "text": "Description: The product unlocks a critical resource more times than intended, leading to an unexpected state in the system. Extended Description: When the product is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity. Consequences: Availability Integrity DoS: Crash, Exit, or Restart Modify Memory Unexpected State Mitigations: Implementation When locking and unlocking a resource, try to be sure that all control paths through the code in which the resource is locked one or more times correspond to exactly as many unlocks. If the product acquires a lock and then determines it is not able to perform its intended behavior, be sure to release the lock(s) before waiting for conditions to improve. Reacquire the lock(s) before trying again.", "url": "https://cwe.mitre.org/data/definitions/765.html"}
{"id": "CWE-786_0", "source": "CWE", "cwe_id": "CWE-786", "title": "Access of Memory Location Before Start of Buffer", "text": "Description: The product reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer. Extended Description: This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. Consequences: Confidentiality Read Memory For an out-of-bounds read, the attacker may have access to sensitive information. If the sensitive information contains system details, such as the current buffer's position in memory, this knowledge can be used to craft further attacks, possibly with more severe consequences. Integrity Availability Modify Memory DoS: Crash, Exit, or Restart Out of bounds memory access will very likely result in the corruption of relevant memory, and perhaps instructions, possibly leading to a crash. Integrity Modify Memory Execute Unauthorized Code or Commands If the corrupted memory can be effectively controlled, it may be possible to execute arbitrary code. If the corrupted memory is data rather than instructions, the system will continue to function with improper changes, possibly in violation of an implicit or explicit policy. Detection Methods: Fuzzing Fuzz testing (fuzzing) is a powerful technique for generating large numbers of diverse inputs - either randomly or algorithmically - and dynamically invoking the code with those inputs.", "url": "https://cwe.mitre.org/data/definitions/786.html"}
{"id": "CWE-786_1", "source": "CWE", "cwe_id": "CWE-786", "title": "Access of Memory Location Before Start of Buffer", "text": "Even with random inputs, it is often capable of generating unexpected results such as crashes, memory corruption, or resource consumption. Fuzzing effectively produces repeatable test cases that clearly indicate bugs, which helps developers to diagnose the issues. High", "url": "https://cwe.mitre.org/data/definitions/786.html"}
{"id": "CWE-824_0", "source": "CWE", "cwe_id": "CWE-824", "title": "Access of Uninitialized Pointer", "text": "Description: The product accesses or uses a pointer that has not been initialized. Extended Description: If the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the product to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks. Depending on memory layout, associated memory management behaviors, and product operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed. Consequences: Confidentiality Read Memory If the uninitialized pointer is used in a read operation, an attacker might be able to read sensitive portions of memory. Availability DoS: Crash, Exit, or Restart If the uninitialized pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur.", "url": "https://cwe.mitre.org/data/definitions/824.html"}
{"id": "CWE-824_1", "source": "CWE", "cwe_id": "CWE-824", "title": "Access of Uninitialized Pointer", "text": "Integrity Confidentiality Availability Execute Unauthorized Code or Commands If the uninitialized pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible. Detection Methods: Automated Static Analysis Automated static analysis, commonly referred to as Static Application Security Testing (SAST), can find some instances of this weakness by analyzing source code (or binary/compiled code) without having to execute it. Typically, this is done by building a model of data flow and control flow, then searching for potentially-vulnerable patterns that connect \"sources\" (origins of input) with \"sinks\" (destinations where the data interacts with external components, a lower layer such as the OS, etc.) High", "url": "https://cwe.mitre.org/data/definitions/824.html"}
{"id": "CWE-825_0", "source": "CWE", "cwe_id": "CWE-825", "title": "Expired Pointer Dereference", "text": "Description: The product dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid. Extended Description: When a product releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the product to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution. Consequences: Confidentiality Read Memory If the expired pointer is used in a read operation, an attacker might be able to control data read in by the application. Availability DoS: Crash, Exit, or Restart If the expired pointer references a memory location that is not accessible to the product, or points to a location that is \"malformed\" (such as NULL) or larger than expected by a read or write operation, then a crash may occur. Integrity Confidentiality Availability Execute Unauthorized Code or Commands If the expired pointer is used in a function call, or points to unexpected data in a write operation, then code execution may be possible. Mitigations: Architecture and Design Choose a language that provides automatic memory management. Implementation When freeing pointers, be sure to set them to NULL once they are freed.", "url": "https://cwe.mitre.org/data/definitions/825.html"}
{"id": "CWE-825_1", "source": "CWE", "cwe_id": "CWE-825", "title": "Expired Pointer Dereference", "text": "However, the utilization of multiple or complex data structures may lower the usefulness of this strategy.", "url": "https://cwe.mitre.org/data/definitions/825.html"}
{"id": "CWE-833_0", "source": "CWE", "cwe_id": "CWE-833", "title": "Deadlock", "text": "Description: The product contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock. Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Other) DoS: Crash, Exit, or Restart Each thread of execution will \"hang\" and prevent tasks from completing. In some cases, CPU consumption may occur if a lock check occurs in a tight loop.", "url": "https://cwe.mitre.org/data/definitions/833.html"}
{"id": "CWE-835_0", "source": "CWE", "cwe_id": "CWE-835", "title": "Loop with Unreachable Exit Condition ('Infinite Loop')", "text": "Description: The product contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop. Consequences: Availability DoS: Resource Consumption (CPU) DoS: Resource Consumption (Memory) DoS: Amplification An infinite loop will cause unexpected consumption of resources, such as CPU cycles or memory. The software's operation may slow down, or cause a long time to respond.", "url": "https://cwe.mitre.org/data/definitions/835.html"}
{"id": "CWE-843_0", "source": "CWE", "cwe_id": "CWE-843", "title": "Access of Resource Using Incompatible Type ('Type Confusion')", "text": "Description: The product allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type. Extended Description: When the product accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access. While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways. This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues. Consequences: Availability Integrity Confidentiality Read Memory Modify Memory Execute Unauthorized Code or Commands DoS: Crash, Exit, or Restart When a memory buffer is accessed using the wrong type, it could read or write memory out of the bounds of the buffer, if the allocated buffer is smaller than the type that the code is attempting to access, leading to a crash and possibly code execution.", "url": "https://cwe.mitre.org/data/definitions/843.html"}
{"id": "CWE-908_0", "source": "CWE", "cwe_id": "CWE-908", "title": "Use of Uninitialized Resource", "text": "Description: The product uses or accesses a resource that has not been initialized. Extended Description: When a resource has not been properly initialized, the product may behave unexpectedly. This may lead to a crash or invalid memory access, but the consequences vary depending on the type of resource and how it is used within the product. Consequences: Confidentiality Read Memory Read Application Data When reusing a resource such as memory or a program variable, the original contents of that resource may not be cleared before it is sent to an untrusted party. Availability DoS: Crash, Exit, or Restart The uninitialized resource may contain values that cause program flow to change in ways that the programmer did not intend. Mitigations: Implementation Explicitly initialize the resource before use. If this is performed through an API function or standard procedure, follow all required steps. Implementation Pay close attention to complex conditionals that affect initialization, since some branches might not perform the initialization. Implementation Avoid race conditions (CWE-362) during initialization routines. Build and Compilation Run or compile the product with settings that generate warnings about uninitialized variables or data.", "url": "https://cwe.mitre.org/data/definitions/908.html"}
